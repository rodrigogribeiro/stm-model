\documentclass[3p,times,procedia]{elsarticle}

\usepackage{ecrc}

\usepackage{booktabs} % For formal tables
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{proof}
\usepackage{amssymb,amsthm}
\usepackage{color,hyperref}

%% set the volume if you know. Otherwise `00'
\volume{00}

%% set the starting page if not 1
\firstpage{1}

%% Give the name of the journal
\journalname{Journal of Logical and Algebraic Methods in Programming}


\jid{JLAMP}

\CopyrightLine{2011}{Published by Elsevier Ltd.}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}


\newcommand{\EvalCtxTran}[1]{\ensuremath{\mathbb{T}[#1]}}
\newcommand{\EvalCtxProc}[1]{\ensuremath{\mathbb{P}[#1]}}

\newtheorem{Lemma}{Lemma}
\newtheorem{Theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{Example}{Example}


\usepackage{color}
\newcommand{\redFG}[1]{\textcolor[rgb]{0.6,0,0}{#1}}
\newcommand{\greenFG}[1]{\textcolor[rgb]{0,0.4,0}{#1}}
\newcommand{\blueFG}[1]{\textcolor[rgb]{0,0,0.8}{#1}}
\newcommand{\orangeFG}[1]{\textcolor[rgb]{0.8,0.4,0}{#1}}
\newcommand{\purpleFG}[1]{\textcolor[rgb]{0.4,0,0.4}{#1}}
\newcommand{\yellowFG}[1]{\textcolor{yellow}{#1}}
\newcommand{\brownFG}[1]{\textcolor[rgb]{0.5,0.2,0.2}{#1}}
\newcommand{\blackFG}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\whiteFG}[1]{\textcolor[rgb]{1,1,1}{#1}}
\newcommand{\yellowBG}[1]{\colorbox[rgb]{1,1,0.2}{#1}}
\newcommand{\brownBG}[1]{\colorbox[rgb]{1.0,0.7,0.4}{#1}}

\newcommand{\ColourStuff}{
  \newcommand{\red}{\redFG}
  \newcommand{\green}{\greenFG}
  \newcommand{\blue}{\blueFG}
  \newcommand{\orange}{\orangeFG}
  \newcommand{\purple}{\purpleFG}
  \newcommand{\yellow}{\yellowFG}
  \newcommand{\brown}{\brownFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\whiteFG}
}

\newcommand{\MonochromeStuff}{
  \newcommand{\red}{\blackFG}
  \newcommand{\green}{\blackFG}
  \newcommand{\blue}{\blackFG}
  \newcommand{\orange}{\blackFG}
  \newcommand{\purple}{\blackFG}
  \newcommand{\yellow}{\blackFG}
  \newcommand{\brown}{\blackFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\blackFG}
}

\ColourStuff

\newcommand{\D}[1]{\blue{\mathsf{#1}}}
\newcommand{\C}[1]{\red{\mathsf{#1}}}
\newcommand{\F}[1]{\green{\mathsf{#1}}}
\newcommand{\V}[1]{\black{\mathsf{#1}}}
\newcommand{\TC}[1]{\purple{\mathsf{#1}}}


\newcommand{\TStep}[9]{\ensuremath{\langle  #2, #3, #4 \rangle
    \mapsto_{T_{#5}} \langle  #7, #8, #9 \rangle}}


\begin{document}

\begin{frontmatter}

\title{A Property Based Testing Approach for Software Transactional Memory Safety}


\author[rgr]{Rodrigo Ribeiro\corref{cor1}}
\ead{rodrigo decsi.ufop.br}

\author[ardb]{Andr\'e Du Bois}
\ead{dubois inf.ufpel.br}


\address[rgr]{Departament of Computing --- Universidade Federal de Ouro Preto, Ouro Preto, Brazil}
\address[ardb]{Departament of Computing --- Universidade Federal de Pelotas, Pelotas, Brazil}


\cortext[cor1]{Corresponding author}



\begin{abstract}
Software Transactional Memory (STM) provides programmers with a simple high-level model of transactions that allows the
writing of concurrent programs without worrying with locks, since all transaction concurrency management is done by
the STM runtime. Such programming model greatly simplifies development of concurrent applications, but it has a cost:
implementing an efficient and correct STM algorithm is an art. Several criteria have been proposed to certify
STM algorithms, some based on model checkers and proof assistants. Such approaches are heavyweight and
do not allow quick experimentation with different TM algorithm designs. In this work, we propose a more
lightweight approach: specify STM algorithm as small-step operational semantics of a idealized language with
STM support and check for safety properties using QuickCheck, a property-based testing library for Haskell.
\end{abstract}

\begin{keyword}
   Software Transactional Memory, Semantics, Opacity, Markability, Property-based Testing
\end{keyword}

\end{frontmatter}



\section{Introduction}

Transactional Memory (TM)~\cite{Herlihy1993,Shavit1995} provides programmers a high level concurrency
control abstraction. Programmers can simply declare certain code pieces as
transactions and the TM runtime guarantees that transactions execute in isolation.
The use of TM provides atomicity, deadlock freedom, composability~\cite{Harris05} and
increases productivity when compared to using locks~\cite{Pankratius2011}. Several works developed
software~\cite{Herlihy2003,Herlihy2006,Dice06}, hardware~\cite{Hammond2004} and software / hardware hybrids~\cite{Baugh2008,Dalessandro2011}
implementations. Gradually, industry is adopting TM: IBM Blue Gene/Q processor supports TM and Intel Haswell microarchitecture
supports transaction synchronization primitives~\cite{TSX,Haring2012}.

The TM runtime is responsible to ensure correct management of shared state. Therefore,
correctness of TM clients depend on a correct implementation of TM algorithms. However,
this simple programming model has a price: designing a correct TM algorithm is an art.
Researchers use different techniques to implement the TM interface efficiently. Algorithms
try to interleave transactions as much as possible, while guaranteeing a non-interleaving
semantics. Thus, subtle but fast algorithms are favored over simpler ones and such subtlety
makes them prone to intricate bugs.


A first step towards correct implementation of TM algorithms is a specification of what
is correctness for TM. Intuitively, a correct TM algorithm should guarantee that every
execution of an arbitrary set of transactions is indistinguishable from a sequential
running of them. Several correctness criteria where proposed in the
literature~\cite{Guerraoui2008,Doherty2009,Imbs2009,LesaniP14} and
they rely on the concept of transactional histories. Intuitively,
a history consists of a sequence of operations executed on shared objects
during a TM execution. Analysing TM history structure generated by algorithms,
we can ensure that its TM interface provides atomicity and deadlock freedom to client
applications. However, certify that a TM algorithm is safe according to some criteria
is a non-trivial task. Different works use I/O automata~\cite{Lesani2012}, model
checking~\cite{CohenPZ08,cohen2007,Guerraoui2008a} or define a specification language that
reduces the problem of proving non-opacity of a TM algorithm to SMT solving~\cite{Lesani2013,DeMoura2008}.

Such correctness concerns are not just formalization curiosity, they can influence directly on implementation efficiency.
Le et.al.~\cite{Le2016} mention that current STM-Haskell implementation does not enjoy opacity and that it
can cause threads to loop, due to accessing an inconsistent memory view. To avoid such problems STM-Haskell
implementation validates the read set each time a thread is scheduled and such checking overhead can cause
a waste of execution time. This is one of the motivation for Le et. al.~\cite{Le2016} proposing a new
implementation of STM-Haskell using the Transaction Locking II (TL2) algorithm~\cite{Dice06}. 

Semanticists have devoted attention to formally specify TM behavior~\cite{Moore2008,Koskinen2010,Abadi2011,Harris05}.
Harris et. al. specifies STM support to Haskell programming language as an extension of GHC compiler~\cite{Harris05},
defines a semantics for a core functional language with STM features and they argue that their semantics is ``small-step'',
but when evaluating an \ensuremath{\F{orElse}} operation or a \ensuremath{\F{atomically}} block, the semantics uses ``multi-steps'' to evaluate such constructs
using the reflexive-transitive closure of single step semantics. Moore et. al. specifies a small-step semantic for TM providing
textual proofs of some safety properties, but their semantic does not provide support for high-level transactional primitives
like \ensuremath{\F{orElse}} and \ensuremath{\F{retry}}~\cite{Moore2008}. Hu et. al. uses property based testing for checking a compiler from a high level
STM language to a transactional virtual machine by defining a stop-the-world semantics for the high-level language and a semantics
for the virtual machine~\cite{Hu08}. Hu et. al. high-level semantics also uses multi-steps to evaluate transactions and does not
provide support for high-level operators like \ensuremath{\F{orElse}} and \ensuremath{\F{retry}}.

Defining formal semantics and correctness criteria are fundamental steps to ensure safety of TM algorithms.
To the best of our knowledge, there is no truly small-step semantics for TM such that: 1) consider high-level constructs like \ensuremath{\F{orElse}}
and \ensuremath{\F{retry}} while allowing the interleaving of executing transactions and 2) produces a history of TM execution that can be used to verify
safety of TM semantics. This work aims to fill this gap. Our approach is to specify STM algorithms
using a standard small-step operational semantics
for a simple transactional language and use property based testing to check if safety properties are satisified by histories generated.
We are aware that using automated testing isn't sufficient to ensure correctness of an algorithm, but
it can expose bugs before using more formal approaches, like formalizing the algorithm in a proof assistant.

Specifically, we made the following contributions:

\begin{itemize}
   \item We define a simplified model language that supports high-level TM constructs 
         \ensuremath{\F{orElse}} and \ensuremath{\F{retry}} present in STM-Haskell.
   \item We define two trace based small-step operational semantics for a high-level 
         language with STM support. One semantics closely follows the well-known TL2
         algorithm~\cite{Dice06} and the other is based on the semantics adopted by STM Haskell~\cite{Harris05}.
         These semantics are implemented in the Haskell programming language.
   \item We define TM safety conditions, namely opacity and markability~\cite{Guerraoui2008,Doherty2009,Imbs2009,LesaniP14},
         in Haskell and check them using QuickCheck~\cite{Claessen00} against the implemented semantics. Defining safety properties
         is just a matter to define functions that verify them on histories produced by interpreters implementing TM algorithm
         semantics.
    \item We check that a compiler from our high-level language to a transactional
          stack-machine preserves safety properties.
          To check this we need to define a trace based semantics for the stack-machine 
          in order to record transactional histories and to fully support our
          simplified high-level language.
\end{itemize}

The rest of this paper is organized as follows. Section \ref{sec:stm-haskell} presents a brief introduction
to software transaction memory, specially its implementation in the Haskell programming language. Section \ref{sec:stm-model}
defines the syntax (Section \ref{sec:stm-syntax}) and operational semantics
based on TL2 and on STM-Haskell (Section \ref{sec:stm-semantics}) for a small STM-Haskell like language.
Section \ref{sec:stm-vm} presents an extension of the
virtual machine and compiler from the high-level language to virtual machine. In Section \ref{sec:stm-safety}
we present Haskell implementations of TM safety properties and describe how to check them using
QuickCheck, giving some details on how random test cases are generated and describe test coverage results.
Section \ref{sec:related} discuss related work and Section \ref{sec:conclusion} concludes and
presents future work.

% All code described in this paper was developed using GHC-8.0.1 and it is available on-line~\cite{}.

\section{Software Transaction Memory}\label{sec:stm-haskell}

\paragraph{STM design space:}
In an STM system, memory transactions can execute concurrently and, if finished without conflicts, a transaction may commit.
Conflict detection may be \emph{eager}, if a conflict is detected the first time a transaction accesses a value, or \emph{lazy}
when it occurs only at commit time. With eager conflict detection, to access a value, a transaction must acquire ownership of
the value, hence preventing other transactions to access it, which is also called pessimistic concurrency control. With optimistic
concurrency control, ownership acquisition and validation occurs only when committing. These design options can be combined for
different kinds of accesses to data, e.g., eager conflict detection for write operations and lazy for reads. STM systems also
differ in the granularity of conflict detection, word based and object based being the most common. 
STM systems need a mechanism for version management. With eager version management, values are updated directly in memory and a
transaction must maintain an undo log where it keeps the original values. If a transaction aborts, it uses the undo log to copy
the old values back to memory. With lazy version management, all writes are buffered in a redo log, and reads must consult this
log to see earlier writes. If a transaction commits, it copies these values to memory, and if it aborts the redo log can be discarded.
An STM implementation can be lock based, or obstruction free. An obstruction free STM does not use blocking mechanisms for
synchronization and guarantees that a transaction will progress even if all other transactions are suspended. Lock based
implementations, although offering weaker progress guarantees, are believed to be faster and easier to implement.

TL2 is a classic lock based, deferred update transactional algorithm, similar to the one used in the GHC implementation of
STM Haskell~\cite{Harris05}: all writes are recorded in a write-set. When a transaction finishes, it validates its log to
check if it has seen a consistent view of memory, and its changes are committed to memory. The main difference of the TL2
algorithm is that conflicts are detected by using a global clock that is shared by all threads. When a transaction starts executing
it reads the global clock to get its read stamp. Every transacted memory
location is associated with a write stamp, when opening an object for reading/writing, the transaction checks
if the write stamp of memory address is not greater than the transaction read stamp, in that case it means that the object
was modified after the transaction started executing, hence the transaction must be aborted. If the memory passes the validation
it means that the transaction has seen a consistent view of the memory.

\paragraph{STM Haskell:}Harris et.al.~\cite{Harris05} extends Haskell with a set of primitives for writing memory transactions.
The main abstractions are transactional variables or \ensuremath{\D{TVar}}s, which are special variables that can only
be accessed inside transactions. Below, the main STM Haskell primitives are shown. The \ensuremath{\F{readTVar}} takes
a \ensuremath{\D{TVar}} and returns a transactional action \ensuremath{\D{STM}\;\V{a}}. This action, when executed, will return a value of
type \ensuremath{\V{a}}, i.e., the \ensuremath{\D{TVar}}'s content. Similarly, \ensuremath{\F{writeTVar}} takes a value of type \ensuremath{\V{a}}, a \ensuremath{\D{TVar}} of the
same type and returns a STM action that when executed writes into the \ensuremath{\D{TVar}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{TVar}\;\V{a}\mathrel{=}\mathbin{...}{}\<[E]%
\\
\>[B]{}\mathkw{data}\;\D{STM}\;\V{a}\mathrel{=}\mathbin{...}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{writeTVar}\mathbin{::}\D{TVar}\;\V{a}\to \V{a}\to \D{STM}\;(){}\<[E]%
\\
\>[B]{}\F{readTVar}\mathbin{::}\D{TVar}\;\V{a}\to \D{STM}\;\V{a}{}\<[E]%
\\
\>[B]{}\F{retry}\mathbin{::}\D{STM}\;(){}\<[E]%
\\
\>[B]{}\F{orElse}\mathbin{::}\D{STM}\;\V{a}\to \D{STM}\;\V{a}\to \D{STM}\;\V{a}{}\<[E]%
\\
\>[B]{}\F{atomically}\mathbin{::}\D{STM}\;\V{a}\to \D{IO}\;\V{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

These transactional actions can be composed together to generate new actions through
monadic combinators or the do notation:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{type}\;\D{Var}\mathrel{=}\D{TVar}\;\D{Float}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{transferMoney}\mathbin{::}\D{Float}\to \D{Var}\to \D{Var}\to \D{STM}\;(){}\<[E]%
\\
\>[B]{}\F{transferMoney}\;\V{amount}\;\V{acc1}\;\V{acc2}\mathrel{=}{}\<[35]%
\>[35]{}\mathkw{do}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\V{v}\leftarrow \F{readTVar}\;\V{acc1}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathkw{if}\;\V{v}\geq \V{amount}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\mathkw{then}\;\mathkw{do}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\F{writeTVar}\;\V{acc1}\;(\V{v}\mathbin{-}\V{amount}){}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\V{v2}\leftarrow \F{readTVar}\;\V{acc2}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\F{writeTVar}\;\V{acc2}\;(\V{v2}\mathbin{+}\V{amount}){}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\mathkw{else}\;\F{retry}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The \ensuremath{\F{retry}} primitive is used to abort and re-execute a transaction once at least one of the
memory positions it has read is modified and \ensuremath{\F{orElse}} is a choice operator, it takes two transactions
as arguments, if the first one retries then the second one is executed. If both fail the whole
transaction is executed again. Transactions are executed with \ensuremath{\F{atomically}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{atomically}\;(\F{transferMoney}\;\C{100.00}\;\V{tvar1}\;\V{tvar2}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
It takes as an argument a transactional action (\ensuremath{\D{STM}\;\V{a}}) and executes it atomically with
respect to other concurrently executing transactions.

\section{A Model for Software Transactional Memory}\label{sec:stm-model}

Our objective is to formalize semantic that ensure, by construction, that an
implementation for transactional memory enjoy safety properties, namely opacity and markability. 

\subsection{Language Syntax}\label{sec:stm-syntax}

Our minimalistic language is defined by data types \ensuremath{\D{Tran}}, which
represents computations in the \ensuremath{\D{STM}} monad, and \ensuremath{\D{Proc}} that denotes
actions in the Haskell \ensuremath{\D{IO}} monad. This language is, in essence,
the same as the one proposed by~\cite{Hu08}. We extend it with
\ensuremath{\F{orElse}}, \ensuremath{\F{retry}}, conditional constructs and a special value to
denote a aborted transaction, \ensuremath{\C{TAbort}}. Such constructs aren't
an essential part of a model for TM, but they interesting
on their own when we consider safety properties of TM.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{newtype}\;\D{Val}\mathrel{=}\D{Val}\;\{\mskip1.5mu \C{ unVal }\mathbin{::}\D{Int}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathkw{newtype}\;\D{Var}\mathrel{=}\D{Var}\;\{\mskip1.5mu \C{ unVar }\mathbin{::}\D{Int}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathkw{newtype}\;\D{Id}\mathrel{=}\D{Id}\;\{\mskip1.5mu \C{unId}\mathbin{::}\D{Int}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathkw{data}\;\D{Tran}\mathrel{=}\C{TVal}\;\D{Val}\mid \C{TRead}\;\D{Var}\mid \C{TWrite}\;\D{Var}\;\D{Tran}{}\<[E]%
\\
\>[B]{}\mid \D{Tran}\C{\,\oplus_T\,}\D{Tran}\mid \C{TIf}\;\D{Tran}\;\D{Tran}\;\D{Tran}{}\<[E]%
\\
\>[B]{}\mid \C{TOrElse}\;\D{Tran}\;\D{Tran}\mid \C{TRetry}\mid \C{TAbort}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathkw{data}\;\D{Proc}\mathrel{=}\C{PVal}\;\D{Val}\mid \C{PFork}\;\D{Proc}{}\<[E]%
\\
\>[B]{}\mid \C{PAt}\;(\D{Maybe}\;(\D{Id},\D{Stamp}))\;\D{Tran}{}\<[E]%
\\
\>[B]{}\mid \D{Proc}\C{\,\oplus_P\,}\D{Proc}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In order to avoid dealing with name binding, we do
not provide a language construct for creating new
variables and also use addition operation for
composing transactions and processes. This is valid simplification,
since addition forms a monoid on integer values, while still retaining
the sequencing computations and combining their results.
We represent variables and values by integers (properly
wrapped using a \ensuremath{\mathkw{newtype}}). Each syntax construct meaning
is immediate with the exception of how we represent atomic blocks. A value built with constructor
\ensuremath{\C{PAt}} carries information about its transaction id and current
transaction read stamp. Initially, all \ensuremath{\C{PAt}} values are built using
\ensuremath{\C{Nothing}} to denote that such block did not started its execution.
To avoid clutter in the presentation of \ensuremath{\C{PAt}} semantics, we represent
information about transaction id and read stamp as $(i,j)$ whenever it
has the form \ensuremath{\C{Just}} $(i,j)$ and as $()$ if it is equal to \ensuremath{\C{Nothing}}. Also,
we allow ourselves a bit of informality and write \ensuremath{\D{Id}}s, \ensuremath{\D{Stamp}}s, \ensuremath{\D{Val}}
and \ensuremath{\D{Var}} values as if they were simple integers.

Construction \ensuremath{\C{TAbort}} is used to represent a transaction
that is aborted by accessing an inconsistent view of memory,
in our TL2-based semantics, and by trying to commit an transaction that
which has accessed and invalid memory configuration, in STM-Haskell based semantics.
Term \ensuremath{\C{TAbort}} does not appear on randomly
generated source programs.
It is used in our semantics to properly
differ between different types of transaction aborting and how
they should be treated by semantics of \ensuremath{\F{orElse}} construct, since
transactions aborted by inconsistent views should not be captured
by an \ensuremath{\F{orElse}}.


\begin{Example}
As an example of how our tiny language can model STM constructs,
consider the following function that increments an value stored on a \ensuremath{\D{TVar}},
if it is different from zero.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\F{incVar}\mathbin{::}\D{TVar}\;\D{Int}\to \D{STM}\;(){}\<[E]%
\\
\>[3]{}\F{incVar}\;\V{v}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\mathrel{=}\mathkw{do}{}\<[E]%
\\
\>[6]{}\hsindent{4}{}\<[10]%
\>[10]{}\V{x}\leftarrow \F{readTVar}\;\V{v}{}\<[E]%
\\
\>[6]{}\hsindent{4}{}\<[10]%
\>[10]{}\mathkw{if}\;\V{x}\equiv \C{0}\;\mathkw{then}\;\F{return}\;(){}\<[E]%
\\
\>[10]{}\hsindent{2}{}\<[12]%
\>[12]{}\mathkw{else}\;\F{writeTVar}\;\V{v}\;(\V{x}\mathbin{+}\C{1}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Such function can be represented in our language as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\F{incVar}\;\V{v}\mathrel{=}\C{TIf}\;(\C{TRead}\;\V{v})\;\C{0}\;(\C{TWrite}\;\V{v}\;(\C{TRead}\;\V{v}\C{\,\oplus_T\,}\C{1})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{Example}

\subsection{Language Semantics}\label{sec:stm-semantics}

In this section, we define two operational semantics for our STM language. First, we
present a semantics inspired by the TL2 algorithm which unlike previous works~\cite{Harris05,Hu08}
uses heaps, transaction logs (read and write sets) and also records the event history of current
TM execution. The use of transaction logs on a high-level semantics is a bit unusual, but necessary
to proper modeling of commit and abort operations of different TM algorithms. Next, we propose a
semantics inspired by STM Haskell in which no global clock is used for \ensuremath{\D{TVar}} version control.

%Following common practice, notation $h\,[x\mapsto v]$ denotes
%finite mapping update, i.e. finite mapping $h'$ such that:
%1) $h'(x) = v$ and 2) $h'(y) = h(y)$, for $x \neq y$.
%To avoid notation clutter, w

Before presenting the semantics, we need to define some notation.
We use finite maps to  represent heaps and logs used by transactions (i.e. read and write
sets). Notation $\bullet$ denotes an empty finite mapping and
$\Theta$ represents a 4-uple formed by a heap and mappings between transaction id's and their
read / write sets and transactions. We let $\Theta_h$, $\Theta_r$, $\Theta_w$, and $\Theta_T$ represent the heap and finite
functions between transaction ids and their logs and transactions,
respectively. Let $h(x)$ denote the operation
of retrieving the value associated with key $x$ in finite mapping 
$h$ and $h(x)=\bot$ denotes that no value is associated
with $x$. Notation $h \uplus h'$ denotes the right-biased union of 
two finite mappings, i.e. when both maps have the same key $x$, we keep
the value $h'(x)$. We let $\Theta_r(x,j)$ denote the operation of
retrieving the value associated with key $x$ in the read set of transaction
with id $j$. Notation $\Theta_w(x,j)$ is defined similarly for write sets. Updating
a variable $x$ with value $v$ in the read set of transaction $j$ is denoted as
$\Theta_r\,[j,x\mapsto v]$. Same holds for write set $\Theta_w$.
Finally, notation $h\mid_{x}$ denotes the finite mapping $h'$ with entries for the key $x$
removed, i.e. $h' = h - [ x \mapsto v]$, for some value $v$.


Operations executed on transactional variables during a TM
execution are represented by data type \ensuremath{\D{Event}}. Essentially,
\ensuremath{\D{Event}} records operations on variables and on transactions.
A history of a TM execution is formed by a list of \ensuremath{\D{Event}}s.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{newtype}\;\D{Stamp}\mathrel{=}\D{Stamp}\;\{\mskip1.5mu \C{ unStamp }\mathbin{::}\D{Int}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathkw{data}\;\D{Event}\mathrel{=}\C{IRead}\;\D{Id}\;\D{Var}\;\D{Val}{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}\mid \C{IWrite}\;\D{Id}\;\D{Var}\;\D{Val}{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}\mid \C{IBegin}\;\D{Id}{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}\mid \C{ICommit}\;\D{Id}{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}\mid \C{IAbort}\;\D{Id}{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}\mid \C{IRetry}\;\D{Id}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathkw{type}\;\D{History}\mathrel{=}[\mskip1.5mu \D{Event}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Data type \ensuremath{\D{Stamp}} denotes the global clock used by the TL2 algorithm to ensure correct variable versions.
Constructors \ensuremath{\C{IBegin}}, \ensuremath{\C{ICommit}} and \ensuremath{\C{IAbort}} denote the beginning, commit and failure of
a transaction with a given \ensuremath{\D{Id}}. We consider that a transaction fails
when it tries to read from an inconsistent view of memory. \ensuremath{\C{IRead}\;\V{id}\;\V{v}\;\V{val}} records that
value \ensuremath{\V{val}} was read by transaction \ensuremath{\V{id}} for variable \ensuremath{\V{v}} and \ensuremath{\C{IWrite}\;\V{id}\;\V{v}\;\V{val}}
denotes that value \ensuremath{\V{val}} was written in variable \ensuremath{\V{v}} by transaction \ensuremath{\V{id}}.
An event \ensuremath{\C{IRetry}} denotes the user called \ensuremath{\F{retry}} on current transaction and such
transaction should be restarted. In our semantics, the computation of histories is represented
as a Writer monad, which adds a new element by appending at history end. But, for presentation
purpouses, we simply add a new event at head of a given history.

\subsubsection{TL2 Based Semantics}

Now, we present our semantics based on Transactional Locking 2 
algorithm~\cite{Dice06}. Informally, TL2 algorithm works as follows:
threads execute reads and writes to objects, but no memory locations are actually modified. All 
writes and reads are recorded in write and read logs. When a
transaction finishes, it validates its log to check if it has seen a 
consistent view of memory, and its changes are committed to memory.

Function $\Theta(x,i,j)$ denotes that transaction $j$ with read-stamp $i$ tries to
to read the content of variable $x$ and it works as follows:
First it checks the write set. If the variable has not been written to, the read set is consulted.
Otherwise, if the variable has also not been read, its value is looked up from the heap and the read log updated accordingly, if
variable's write stamp is not greater than current transaction read-stamp $i$. Otherwise, we have an conflict and the current
transaction is aborted by returning \ensuremath{\C{TAbort}}.

\begin{figure}[h]
  \[
  \Theta(x,i,j) = \left\{
  \begin{array}{ll}
     (v,\Theta) & \textit{if }\:\Theta_w(x,j) = (i',v)\\
     (v,\Theta) & \textit{if }\:\Theta_w(x,j) = \bot,\Theta_r(x,j) \neq \bot, \\
                & \:\:\:\:\: \Theta_h(x) = (i',v) \textit{ and } i \geq i'\\
     (v, \Theta_r\,[j,x \mapsto v]) & 
        \textit{if }\:\Theta_w(x) = \Theta_r(x) = \bot,\\
                                       & \:\:\:\:\:  \Theta_h(x) = (i',v),
                                     \textit{ and } i \geq i' \\
                           \ensuremath{\C{TAbort}} & \textit{if }\: \Theta_h(x) = (i',v)
                                    \textit{ and } i < i'
  \end{array}
                                  \right.
  \]
  \centering
  \caption{Reading a variable}
  \label{fig:readvar}
\end{figure}

Predicate $consistent(\Theta,i,j)$ holds if transaction $j$ has finished its execution
on a valid view of memory. We say that a TM state $\Theta$ is consistent if all variables read
have stamps less than or equal to $i$, the global clock value in which transaction $j$ have started.

\begin{figure}[h]
  \[
     consistent(\Theta,i,j) = \forall x. \Theta_r(x,j) = (i,v) \to
     \Theta_h(x) = (i',v) \land i \geq i'
  \]
  \centering
  \caption{Predicate for consistency of transaction logs}
  \label{fig:consistency}
\end{figure}


In order to provide a concise semantics definition, in Figure~\ref{fig:hole-syntax},
we define evaluation contexts to avoid the need of ``congruence rules''. In our
semantics definition we use the following meta-variable convention: we let $t$
denote arbitrary transactions and $p$ processes. Values are represented by $v$,
stamps by $i$ and transaction ids by $j$. All meta-variables can appear primed or subscripted, as
usual. Finally, in order to avoid several rules to propagating different types of
transaction failure, we use \ensuremath{\C{TFail}} whenever any of \ensuremath{\C{TAbort}} or \ensuremath{\C{TRetry}} applies.
Same holds for events: \ensuremath{\C{IFail}} will represent any of \ensuremath{\C{IAbort}} or \ensuremath{\C{IRetry}}.  

\begin{figure}[h]
        \[
              \begin{array}{c}
                   \textit{Evaluation contexts for transactions} \\
                   \\
                   \begin{array}{rcl}
                      \EvalCtxTran{\cdot} & ::=    & \ensuremath{\C{TWrite}}\, v\:\EvalCtxTran{\cdot}\\
                                                   & \mid &\EvalCtxTran{\cdot}\: \ensuremath{\C{\,\oplus_T\,}} t\\
                                                   & \mid & \ensuremath{\C{TVal}}\,v \ensuremath{\C{\,\oplus_T\,}} \EvalCtxTran{\cdot}\\
                                                   & \mid & \ensuremath{\C{TIf}}\:\EvalCtxTran{\cdot}\:t\:t' \\
                                                   & \mid & \ensuremath{\C{TOrElse}}\:\EvalCtxTran{\cdot}\:t\\
                   \end{array}
                    \\
                \\
                    \textit{Evaluation contexts for processes}\\
                    \\
                    \begin{array}{rcl}
                      \EvalCtxProc{\cdot} & ::=    & \ensuremath{\C{PFork}}\:\EvalCtxProc{\cdot}\\
                                                   & \mid &\EvalCtxProc{\cdot}\:\ensuremath{\C{\,\oplus_P\,}} t\\
                                                   & \mid & \ensuremath{\C{PVal}}\,v\,\ensuremath{\C{\,\oplus_P\,}}\EvalCtxProc{\cdot}\\
                                                   & \mid & \ensuremath{\C{PAt}}\,(\ensuremath{\C{Just}}\, (i,j))\:\EvalCtxProc{\cdot}
                    \end{array}
              \end{array}
        \]
        \centering
        \caption{Evaluation contexts for high-level language.}
        \label{fig:hole-syntax}
\end{figure}

\paragraph{Transaction Semantics:}

We define transaction semantics by a reduction relation $\mapsto_{T_{i\,j}}$ on triples
$\langle \Theta, \sigma, t \rangle$, where $\Theta$ is the current state of TM,
$\sigma$ is the history of TM execution and $t$ is a transaction. Variables $i$ and $j$
denote the current transaction read stamp and id, respectively. First, we present
the rule used to evaluate transaction contexts.

\[
  \infer[_{(TContext)}]
        { \langle \Theta,\,\sigma,\,\EvalCtxTran{t}\rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\,\sigma',\,\EvalCtxTran{t'}\rangle }
        { \langle \Theta,\,\sigma,\,t \rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\,\sigma',\, t'\rangle }
\]

This rule simply allows stepping some subterm of current transaction expression $\EvalCtxTran{t}$.

Next, we will consider how to evaluate a \ensuremath{\C{TRead}} construct. Notice that, 
we need two different rules for reading variables. This happens because, in our semantics, the
function that reads a value from a variable can abort the current transaction, as it happens in TL2,
if its write stamp is less than current transactions read stamp.

\[
\begin{array}{c}
  \infer[_{(TReadOk)}]
        { \langle \Theta,\, \sigma, \ensuremath{\C{TRead}}\,v \rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\, \sigma',\,\ensuremath{\C{TVal}}\,val\rangle }
        {\Theta(v,i,j) = (val,\Theta') & \sigma' = \ensuremath{\C{IRead}}\,j\,v\,val\,:\sigma}
  \\
  \\
  \infer[_{(TReadFail)}]
        { \langle \Theta,\, \sigma, \ensuremath{\C{TRead}}\,v \rangle \mapsto_{T_{i\,j}}
          \langle \Theta, \, \sigma',\, \ensuremath{\C{TAbort}} \rangle}
        {\Theta(v,i,j) = (\ensuremath{\C{TAbort}},\Theta') & \sigma' = \ensuremath{\C{IAbort}}\,j\,:\sigma} 
\end{array}
\]

Writing a value is done by next rules: rule $(TWriteVal)$ writes a completely
reduced value and rule $(TWriteFail)$ just does propagate failure for
signaling that current transaction has failed or aborted throught an explicit
\ensuremath{\C{TRetry}}.

\[
\begin{array}{c}
  \infer[_{(TWriteVal)}]
        { \langle \Theta, \, \sigma, \ensuremath{\C{TWrite}}\,v\,(\ensuremath{\C{TVal}}\,val)\rangle \mapsto_{T_{i\,j}}
          \langle \Theta', \, \sigma',\,\ensuremath{\C{TVal}}\,val\rangle}
        {\begin{array}{c}
            \Theta' = \langle \Theta_h, \Theta_r, \Theta_w[j,x \mapsto val], \Theta_T\rangle \\
            \sigma' = \ensuremath{\C{IWrite}}\,j\,v\,val\, : \sigma \\
         \end{array}}
  \\ \\
  \infer[_{(TWriteFail)}]
        { \langle \Theta, \,\sigma, \ensuremath{\C{TWrite}}\,v\,\ensuremath{\C{TFail}}\rangle \mapsto_{T_{i\,j}}
          \langle \Theta, \, \sigma,\, \ensuremath{\C{TFail}} \rangle }
        { }
\end{array}
\]

Since we replace monadic bind by addition, we need to
force a sequential order of evaluation and some additional
rules to ensure the correct propagation of
failure.

\[
\begin{array}{c}
  \infer[_{(TAddVal)}]
        { \langle \Theta, \, \sigma,\, (\ensuremath{\C{TVal}}\,val_1) \ensuremath{\C{\,\oplus_T\,}} (\ensuremath{\C{TVal}}\,val_2) \rangle \mapsto_{T_{i\,j}}
          \langle \Theta, \, \sigma,\, \ensuremath{\C{TVal}}\,val \rangle}
        {val = val_1 + val_2}
  \\ \\
  \infer[_{(TAddL)}]
        { \langle \Theta,\,\sigma,\,\ensuremath{\C{TFail}}\,\ensuremath{\C{\,\oplus_T\,}} t\rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\,\sigma', \ensuremath{\C{TFail}}\rangle}
        { }

%\langle \Theta,\,\sigma,\,t\rangle \mapsto_{T_{i\,j}}
%         \langle \Theta',\,\sigma',\,|TFail|\rangle 

  \\ \\
  \infer[_{(TAddR)}]
        { \langle \Theta,\,\sigma,\, (\ensuremath{\C{TVal}}\, val) \ensuremath{\C{\,\oplus_T\,}} \ensuremath{\C{TFail}} \rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\,\sigma',\,\ensuremath{\C{TFail}} \rangle }
        { }
\end{array}
\]

We can evaluate a \ensuremath{\C{TIf}} to its first branch if its condition is equal to zero or to its
second otherwise. 

\[
  \begin{array}{c}
     \infer[_{(TIfZero)}]
           {\langle \Theta,\sigma,\ensuremath{\C{TIf}}\,(\ensuremath{\C{TVal}\;\C{0}})\,t\,t'\rangle \mapsto_{T_{i\,j}}
            \langle \Theta,\sigma,\,t\rangle}
           {}
     \\ \\
     \infer[_{(TIfNonZero)}]
           {\langle \Theta,\sigma,\ensuremath{\C{TIf}}\,(\ensuremath{\C{TVal}\;\V{v}})\,t\,t'\rangle \mapsto_{T_{i\,j}}
            \langle \Theta,\sigma,\,t'\rangle}
           {v \neq 0}          
  \end{array}
\]

We also propagate failures produced on \ensuremath{\C{TIf}} condition evaluation.

\[
  \begin{array}{c}
     \infer[_{(TIfFail)}]
           { \langle \Theta,\,\sigma,\,\ensuremath{\C{TIf}}\,\ensuremath{\C{TFail}}\,t\,t'\rangle\mapsto_{T_{i\,j}}
             \langle \Theta,\,\sigma,\,\ensuremath{\C{TFail}}\rangle }
           {}
  \end{array}
\]

Evaluating a \ensuremath{\C{TOrElse}} construct returns a value, if whenever its left transaction
reduces to \ensuremath{\C{TVal}\;\V{v}}. Right transaction is executed only when the left one reduces to
\ensuremath{\C{TRetry}}. Finally, if a transaction aborts such aborting signal is propagated.

\[
  \begin{array}{c}
     \infer[_{(TOrElseVal)}]
           { \langle \Theta,\,\sigma,\,\ensuremath{\C{TOrElse}}\,(\ensuremath{\C{TVal}}\:v)\,t'\rangle \mapsto_{T_{i\,j}}
             \langle \Theta',\,\sigma',\,\ensuremath{\C{TVal}}\,v \rangle }
           {  }
     \\ \\
     \infer[_{(TOrElseR)}]
           { \langle \Theta,\,\sigma,\,\ensuremath{\C{TOrElse}}\,\ensuremath{\C{TRetry}}\,t'\rangle \mapsto_{T_{i\,j}}
             \langle \Theta,\,\sigma,\,t' \rangle }
           { }
      \\ \\
     \infer[_{(TOrElseA)}]
           { \langle \Theta,\,\sigma,\,\ensuremath{\C{TOrElse}}\,\ensuremath{\C{TAbort}}\,t'\rangle \mapsto_{T_{i\,j}}
             \langle \Theta,\,\sigma,\,\ensuremath{\C{TAbort}} \rangle }
           {  }
  \end{array}
\]


\paragraph{Process Semantics:}

The semantics for processes, $\mapsto_{P}$, acts on 5-uples $\langle \Theta,\sigma,j,i,s\rangle$
consisting of a TM state $\Theta$, a history of transaction execution $\sigma$,
last transaction id used $j$, a global clock $i$ and a process soup $s$.

We begin the presentation of process semantics with context rule, which allows
steps of inner expressions.

\[
  \infer[_{(PContext)}]
        { \langle \Theta,\,\sigma,\,j,\,i,\EvalCtxProc{p} : s\rangle \mapsto_{P}
          \langle \Theta,\,\sigma',\,j',\,i',\,\EvalCtxProc{p'} : s\rangle }
        { \langle \Theta,\,\sigma,\,j,\,i,\,t \rangle \mapsto_{P}
          \langle \Theta',\,\sigma',\,j',\,i',\, t'\rangle }
\]

Process soup are represented by a list of processes and its execution proceeds by
pattern matching on the first element of such list. In order to allow non-determinism
we introduce a rule for preemption.

\[
   \infer[_{(PPreempt)}]
         { \langle \Theta,\,\sigma,\,j,\,i,\,p : s\rangle \mapsto_{P}
           \langle \Theta',\,\sigma',\,j',\,i',p : s'\rangle }
         { \langle \Theta,\,\sigma,\,j,\,i,\,s\rangle \mapsto_{P}
           \langle \Theta',\,\sigma',\,j',\,i',\,s'\rangle } 
\]

Evaluating a \ensuremath{\C{PFork}} adds a process $p$ to current soup returning $0$.

\[
    \infer[_{(PFork)}]
          {\langle \Theta,\,\sigma,\,j,\,i,\, (\ensuremath{\C{PFork}}\,p) : s \rangle \mapsto_{P}
           \langle \Theta,\,\,\sigma,\,j,\,i,\, s' \rangle}
          {s' = \ensuremath{\C{PVal}}\,0 : p : s}
\]

As we did with transaction, process composition is done using addition.

\[
\begin{array}{c}
  \infer[_{(Add1)}]
        { \langle \Theta, \, \sigma,\,j,\,i,\, (\ensuremath{\C{PVal}}\,v_1) \ensuremath{\C{\,\oplus_P\,}} (\ensuremath{\C{PVal}}\,v_2) \rangle \mapsto_{P}
          \langle \Theta, \, \sigma,\,j,\,i,\, \ensuremath{\C{PVal}}\,v \rangle}
        {v = v_1 + v_2}
\end{array}
\]
Finally, we now present the semantics for atomic blocks. Unlike previous works~\cite{Hu08,Harris05},
the semantics of atomic blocks do not follow the so-called stop-the-world-semantics.
This design choice is justified by the fact that stop-the-world semantics naturally enjoys safety conditions
like opacity and markability. Since our objective is to exploit failures in STM algorithms represented as small-step semantics
of our simple transactional language, the proposed semantics reduces atomic blocks in a step-wise manner instead of using
a multi-step approach.

The first rule for reducing a \ensuremath{\C{PAt}} block is presented below. It basically updates the TM state with empty
read and write sets for the newly started transaction $j$, register it using \ensuremath{\C{IBegin}} $j$ and reinsert process
\ensuremath{\C{PAt}} $(i,j)\,t$ at the end of process soup. Notice that, initially, every atomic block does not have its
read stamp and transaction id. When a transaction $t$ is started, we update its process to store its starting clock and transaction id.

\[
  \begin{array}{c}
  \infer[_{(PAt1)}]
        {\langle \Theta,\,\sigma,\,j,\,i,\,\ensuremath{\C{PAt}}\,\ensuremath{()}\,t : s\rangle\mapsto_{P}
         \langle \Theta',\,\sigma',\,j + 1,\,i,\, s'\rangle}
        {\begin{array}{c}
         \Theta_1 = \langle \Theta_h, \Theta_r\,[j\mapsto \bullet], \Theta_w\,[j\mapsto \bullet], \Theta_T\,[j\mapsto t]\rangle\\
         s' = s \ensuremath{\plus } [\ensuremath{\C{PAt}}\,(i,j)\,t] \\
         \sigma' = \ensuremath{\C{IBegin}}\,j : \sigma
         \end{array}}
  \end{array}      
\]

After initializing a transaction, its execution proceeds thanks to rules $PPrempt$ and $PContext$. Whenever a
transaction successfully reduces to a value and it had executed in a consistent view of memory, we can use next
rule to commit its results to heap.

\[
  \begin{array}{c}
     \infer[_{(PAt2)}]
           {\langle \Theta,\,\sigma,\,j,\,i,\,\ensuremath{\C{PAt}}\,v : s \rangle \mapsto_{P}
            \langle \Theta',\,\sigma',\,j,\,i + 1,\,\ensuremath{\C{PVal}}\,n : s \rangle}
           {\begin{array}{cc}
              v = \ensuremath{\C{TVal}}\, n         & consistent(\Theta,i,j) \\
              \sigma' = \ensuremath{\C{ICommit}}\,j : \sigma & 
              \Theta' = \langle \Theta_h',\,\Theta_r\mid_j,\,\Theta_w\mid_j \rangle \\
              \multicolumn{2}{c}{\Theta_h'  = \Theta_h \uplus \Theta_w(j)} \\
            \end{array}}
  \end{array}
\]
We first check consistency using $consistent(\Theta,i,j)$, register a successful commit in history $\sigma$ using
\ensuremath{\C{ICommit}} $j$ and update TM state $\Theta$ by: 1) writing the write set contents of transaction $j$ in the heap and
2) removing the read and write set of transaction $j$ from TM state.

Whenever a transaction reduces to \ensuremath{\C{TRetry}} or \ensuremath{\C{TAbort}} (represented by \ensuremath{\C{TFail}}), it should be restarted.
For this, we remove entries for the transaction $j$ from transactions and read / write set mappings.
Also, we reinsert a process with the original transaction in the process soup to allow the restarting
of this transaction. This is specified by next rule.

\[
  \begin{array}{c}
     \infer[_{(PAt3)}]
           {\langle \Theta,\,\sigma,\,j,\,i,\,\ensuremath{\C{PAt}}\,\ensuremath{\C{TFail}} : s \rangle \mapsto_{P}
            \langle \Theta',\,\sigma,\,j + 1,\,i,\,s' \rangle}
           {\begin{array}{c}
              \Theta' = \langle\Theta_h,\Theta_r\mid_j,\Theta_w\mid_j,\Theta_T\mid_j\rangle\\
              s' = s \ensuremath{\plus } \ensuremath{\C{PAt}}\,()\,t\,\,\,\,\,\,\,t = \Theta_t(j)
            \end{array}}
  \end{array}
\]

\subsubsection{STM-Haskell Based Semantics}

Essentially, the STM-Haskell based semantics is just a simplification of the previouly defined one in which
we do not take into account the global clock to ensure consistency of transaction logs. This change simplifies
both the semantics and their auxiliar definitions to read variables and check for consistency of TM state.

In Figure~\ref{fig:readvar1}, we redefine the function for reading a value from a variable. Note that this is
almost the definition of Figure~\ref{fig:readvar} except that it does not use a global clock for
version control of variables in read set.

\begin{figure}[h]
  \[
  \Theta(x,j) = \left\{
  \begin{array}{ll}
     (v,\Theta) & \textit{if }\:\Theta_w(x,j) = (i,v)\\
     (v,\Theta) & \textit{if }\:\Theta_w(x,j) = \bot,\Theta_r(x,j) \neq \bot, \\
                & \:\:\:\:\: \Theta_h(x) = (i,v) \\
     (v, \Theta_r\,[j,x \mapsto (i,v)]) & 
        \textit{if }\:\Theta_w(x) = \Theta_r(x) = \bot,\\
                                       & \:\:\:\:\:  \Theta_h(x) = (i,v)
  \end{array}
                                  \right.
  \]
  \centering
  \caption{Reading a variable}
  \label{fig:readvar1}
\end{figure}

Also, since we do not abort current transaction when reading a value from a inconsistent
memory view, the rule $(TReadFail)$ isn't necessary in STM-Haskell based semantics. When writing
values to variables, the only change needed is to increment variable's write stamp.
Modified rule is presented below.

\[
  \begin{array}{l}
  \infer[_{(TWriteVal)}]
        { \langle \Theta, \, \sigma, \ensuremath{\C{TWrite}}\,v\,(\ensuremath{\C{TVal}}\,val)\rangle \mapsto_{T_{i\,j}}
          \langle \Theta', \, \sigma',\,\ensuremath{\C{TVal}}\,val\rangle}
        {\begin{array}{c}
            \Theta' = \langle \Theta_h, \Theta_r, \Theta_w[j,x \mapsto (i',val)], \Theta_T\rangle \\
            \sigma' = \ensuremath{\C{IWrite}}\,j\,v\,val\, : \sigma \\
         \end{array}}
  \end{array}
\]


We also need to modify the consistency check. In the original STM-Haskell paper~\cite{Harris05}, consistency
of TM state is tested before a commit in order to validade if a transaction has accessed a valid memory view.
This validity test essentially checks pointer equalities for values in read set. Since in our model we have no
notion of pointer, we use value equality for consistency check as in~\cite{Hu08}.
\begin{figure}[h]
  \[
     consistent(\Theta,j) = \forall x. \Theta_r(x,j) = \Theta_h(x)
  \]
  \centering
  \caption{Predicate for consistency of transaction logs}
  \label{fig:consistency1}
\end{figure}

Semantics for transactions and processes are essentially the same presented in previous section. Rules will
differ only by: 1) Information about TL2 global clock isn't present and 2) it uses the modified consistency
check and reading values from the TM state function presented in this section. For space reasons, we do not
present this slightly modified set of semantic rules.


\section{A Transactional Virtual Machine}\label{sec:stm-vm}

% In previous sections we have presented semantic for a high-level language with STM support. Hu et. al.~\cite{Hu08}
% defined a simplified language for STM and a virtual machine (VM) for verifying that compilation preserves
% the semantics of high-level language programs. In this work, we follow their approach to assert preservation of
% safety properties by the compiler. 

\subsection{Instruction Set}

Our instruction set extends the one proposed by~\cite{Hu08} with constructions to support conditionals, \ensuremath{\F{orElse}} and
\ensuremath{\F{retry}} constructs. Conditionals are compiled using jump instructions and \ensuremath{\F{orElse}} and \ensuremath{\F{retry}} use instructions that
``store''  on VM stack code for exception handling, following the approach used by Hutton et.al.~\cite{Hutton07}.
The syntax of our instruction set is defined by the following data type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Instr}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\C{Push}\;\D{Val}\mid \C{Add}\mid \C{Read}\;\D{Var}\mid \C{Write}\;\D{Var}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \C{Begin}\mid \C{Commit}\mid \C{Fork}\;\D{Code}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\orange{\texttt{-- new instructions}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \C{Jump}\;\D{Offset}\mid \C{JumpFalse}\;\D{Offset}\mid \C{Retry}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \C{Mark}\;\D{Code}\mid \C{Unmark}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Operation \ensuremath{\C{Push}} places a value on the machine stack and \ensuremath{\C{Add}} pops two values from stack and pushes its sum. Instruction \ensuremath{\C{Read}} pushes
the value of a variable onto the stack and \ensuremath{\C{Write}} updates the variable with topmost value in the VM stack. Instructions \ensuremath{\C{Begin}} and \ensuremath{\C{Commit}}
mark the start and finish of transactions and \ensuremath{\C{Fork}} spawns a new process.
Instruction \ensuremath{\C{Retry}} is used to compile a call to \ensuremath{\C{TRetry}} and
\ensuremath{\C{Mark}} places \ensuremath{\C{Retry}} handling code in VM stack while \ensuremath{\C{Unmark}} is the instruction responsible to remove a handler code from stack.
Both \ensuremath{\C{Mark}} and \ensuremath{\C{Unmark}} are necessary to compile \ensuremath{\C{TOrElse}} construct.

Type \ensuremath{\D{Offset}} is just a synonym for \ensuremath{\D{Int}} and denotes how much should we move to execute the next instruction. Data type
\ensuremath{\D{Code}} is just a zipper~\cite{Huet97} for a list of \ensuremath{\D{Instr}}. 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Code}\mathrel{=}\D{Code}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\C{executed}\mathbin{::}[\mskip1.5mu \D{Instr}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{},\C{nexts}{}\<[22]%
\>[22]{}\mathbin{::}[\mskip1.5mu \D{Instr}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In this enconding of list zippers, the current value on cursor is the head of \ensuremath{\C{nexts}} field.
In VM semantics we represent values of data type code as a pair $\langle exs , nxs\rangle$ of \ensuremath{\D{Instr}} lists.
This simplifies the presentation of how the semantics deal with control structures.

\subsection{Compiler}


In this section we present functions \ensuremath{\F{compileProc}}
and \ensuremath{\F{compileTran}} that translate processes and transactions to
VM instructions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{compileProc}\mathbin{::}\D{Proc}\to [\mskip1.5mu \D{Instr}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileProc}\;(\C{PVal}\;\V{v}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}[\mskip1.5mu \C{Push}\;\V{v}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileProc}\;(\V{x}\C{\,\oplus_P\,}\V{y}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{compileProc}\;\V{x}\plus {}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\F{compileProc}\;\V{y}\plus [\mskip1.5mu \C{Add}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileProc}\;(\C{PAt}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\C{Begin}\mathbin{:}(\F{compileTran}\;\V{t})\plus [\mskip1.5mu \C{Commit}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileProc}\;(\C{PFork}\;\V{p}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}[\mskip1.5mu \C{Fork}\;(\F{compileProc}\;\V{p})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Compilation of transactions proceeds as follows:
To compile a \ensuremath{\C{TRetry}} we just build a list containing a \ensuremath{\C{Retry}} instruction and
conditionals are compiled using jumps and their offset is calculated from the result of
compiling then and else branches. To compile a transaction \ensuremath{\V{t}\mathbin{`\C{TOrElse}`}\V{t1}} we generate
a \ensuremath{\C{Mark}} instruction containing the code built from \ensuremath{\V{t1}}, that will be put on VM stack and
executed only if code for \ensuremath{\V{t}} reduces to \ensuremath{\C{TRetry}}, followed by compiled code for \ensuremath{\V{t}} and a
trailing \ensuremath{\C{Unmark}} instruction, to remove handler code from stack, if \ensuremath{\V{t}} executes without
reducing to a \ensuremath{\C{Retry}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{compileTran}\mathbin{::}\D{Tran}\to [\mskip1.5mu \D{Instr}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileTran}\;(\C{TVal}\;\V{i}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}[\mskip1.5mu \C{Push}\;\V{i}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileTran}\;(\V{x}\C{\,\oplus_T\,}\V{y}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{compileTran}\;\V{x}\plus \F{compileTran}\;\V{y}\plus [\mskip1.5mu \C{Add}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileTran}\;(\C{TRead}\;\V{v}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}[\mskip1.5mu \C{Read}\;\V{v}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileTran}\;(\C{TWrite}\;\V{v}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{compileTran}\;\V{t}\plus [\mskip1.5mu \C{Write}\;\V{v}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileTran}\;\C{TRetry}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}[\mskip1.5mu \C{Retry}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileTran}\;(\V{t}\mathbin{`\C{TOrElse}`}\V{t'}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}[\mskip1.5mu \C{Mark}\;(\D{Code}\;[\mskip1.5mu \mskip1.5mu]\;(\F{compileTran}\;\V{t'}))\mskip1.5mu]\plus {}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\F{compileTran}\;\V{t}\plus {}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}[\mskip1.5mu \C{Unmark}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{compileTran}\;(\C{TIf}\;\V{t}\;\V{t'}\;\V{t''}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{compileTran}\;\V{t}\plus {}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}[\mskip1.5mu \C{JumpFalse}\;\V{off1}\mskip1.5mu]\plus {}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\V{c1}\plus [\mskip1.5mu \C{Jump}\;\V{off2}\mskip1.5mu]\plus \V{c2}{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\V{c1}\mathrel{=}\F{compileTran}\;\V{t'}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\V{off1}\mathrel{=}\F{length}\;\V{c1}\mathbin{+}\C{1}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\V{c2}\mathrel{=}\F{compileTran}\;\V{t''}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\V{off2}\mathrel{=}\F{length}\;\V{c2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Virtual Machine Semantics}

The VM semantics is specified as a transition relation $\mapsto_{VM}$ between 4-uples $\langle \Theta_h, \sigma, j, s \rangle$, comprising
a heap $\Theta_h$, a history $\sigma$, next transaction id $j$ and a thread soup $s$. In turn, threads are represented by 5-uples of the form
$\langle c,\,\rho,\,f,\,\Theta_r,\,\Theta_w\rangle$, where $c$ is the code to be executed, $\rho$ is the thread local stack,
$f$ is the code to be re-executed in case of failure and $\Theta_r$ and $\Theta_w$ are read and
write-sets, respectively.
Type \ensuremath{\D{StkCell}} represents an entry on a thread stack which can be a value or code to be executed whenever a \ensuremath{\C{Retry}} instruction is found
during VM execution. We allow ourselves a bit of informality and represent values of type \ensuremath{\D{StkCell}} without explicitly mark them with
constructors \ensuremath{\C{SVal}} and \ensuremath{\C{Han}}. We use variables $n$ and $m$ to denote \ensuremath{\C{SVal}} values and $c,c'$ to denote \ensuremath{\C{Han}}. The main motivation
is to avoid clutter in presenting VM semantics.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{StkCell}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathrel{=}\C{SVal}\;\D{Val}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mid \C{Han}\;\D{Code}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathkw{type}\;\D{Stack}\mathrel{=}[\mskip1.5mu \D{StkCell}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The first rule of the VM semantics is to allow preemption, giving rise to non-deterministic execution.

\[
   \infer[_{(Preempt)}]
         {\langle \Theta_h,\,\sigma,\,j,\, t : s \rangle \mapsto_{VM} \langle \Theta_h',\sigma',\,j',\,t : s' \rangle}
         {\langle \Theta_h,\,\sigma,j\,s\rangle \mapsto_{VM} \langle \Theta_h',\,\sigma',j',s'\rangle}
\]

The semantics of \ensuremath{\C{Fork}} adds a new thread to soup with empty read and write-sets.

\[
  \infer[_{(Fork)}]
        { \langle \Theta_h,\,\sigma,j,\,\langle C,\,\rho,\,f,\,\Theta_r,\,\Theta_w\rangle:s\rangle\mapsto_{VM}
          \langle \Theta_h,\,\sigma,j,\,t:t':s\rangle }
        { \begin{array}{cc}
            C = \langle exs, \ensuremath{\C{Fork}}\,c' : c\rangle & C' = \langle \ensuremath{\C{Fork}}\,c' : exs,c\rangle \\
            t = \langle C',\,0:\rho,\,f,\,\Theta_r,\,\Theta_w\rangle & t' = \langle \langle [], c' \rangle, [],[], \bullet,\bullet\rangle \\
          \end{array}}
\]

Instructions \ensuremath{\C{Push}} and \ensuremath{\C{Add}} modify the stack by putting a new value on top of the stack and poping two values and
pushing their sum on the thread local stack.
\[
  \begin{array}{c}
     \infer[_{(Push)}]
           {\langle \Theta_h,\,\sigma,j,\,\langle C,\,\rho,\,f,\,\Theta_r,\,\Theta_w\rangle : s\rangle\mapsto_{VM}
            \langle \Theta_h,\,\sigma,j,\,t : s \rangle}
           {\begin{array}{c}
               C = \langle exs, \ensuremath{\C{Push}}\,n:c\rangle \\
               t = \langle \langle \ensuremath{\C{Push}}\, n : exs, c\rangle ,\,n:\rho,\,f,\,\Theta_r,\,\Theta_w\rangle 
            \end{array}} \\ \\
     \infer[_{(Add)}]
           {\langle \Theta_h,\,\sigma,j,\, t: s\rangle\mapsto_{VM}
            \langle \Theta_h,\,\sigma,j,\,t' : s \rangle}
           {\begin{array}{c}
              C = \langle exs, \ensuremath{\C{Add}} : c \rangle \\
              t = \langle C,\,n:m:\rho,\,f,\,\Theta_r,\,\Theta_w\rangle \\ 
              t' = \langle c,\, (n + m) : \rho,\,f,\,\Theta_r,\,\Theta_w\rangle
            \end{array}} 
  \end{array}
\]

\ensuremath{\C{Begin}} starts a new transaction execution by cleaning the read and write sets, setting code that should be executed
when a failure happens, register in history $\sigma$ the start of transaction and increments the transaction.

\[
  \infer[_{(Begin)}]
        { \langle \Theta_h,\sigma,j, t : s\rangle \mapsto_{VM}
          \langle \Theta_h,\sigma',j + 1, t' : s\rangle }
        {\begin{array}{c}
           t = \langle \langle exs, \ensuremath{\C{Begin}} : c\rangle,\rho, f,\Theta_r,\Theta_w\rangle \\ 
           t' = \langle \langle \ensuremath{\C{Begin}} : exs, c\rangle, [] , \ensuremath{\C{Begin}} : c,\bullet,\bullet\rangle
         \end{array}}
\]

\ensuremath{\C{Read}} pushes the value of variable v on top of the stack. First it consults the write log.
If the variable has not been written to, the read log is then consulted. Otherwise, if the variable has
also not been read, its value is looked up from the heap and the read log updated accordingly. In all situations described,
a read for the variable is recorded.
\[
  \begin{array}{l}
  \infer[_{(Read)}]
        {\langle \Theta_h,\sigma,j,t : s \rangle \mapsto_{VM}
         \langle \Theta_h,\sigma',j,t' : s \rangle}
        {\begin{array}{c}
            \sigma' = \ensuremath{\C{IRead}}\,(j-1)\,v\,n\, : \sigma\\
            t = \langle \langle exs, \ensuremath{\C{Read}}\,v : c\rangle,\rho,f,\Theta_r,\Theta_w\rangle \\
            t' = \langle  \langle \ensuremath{\C{Read}}\,v : exs, c\rangle ,n : \rho,f,\Theta_r',\Theta_w\rangle \\
         \end{array}} \\ \\
  \langle n , \Theta_r' \rangle 
       = \left \{
            \begin{array}{ll}
               \langle \Theta_w(v), \Theta_r \rangle & \text{if } v \in dom(\Theta_w)\\
               \langle \Theta_r(v), \Theta_r \rangle & \text{if } v \in dom(\Theta_r)\\
               \langle \Theta_h(v), \Theta_r\,[v \mapsto \Theta_h(v)]\rangle & \text{otherwise.} 
            \end{array}
         \right .
  \end{array} 
\]

Operation \ensuremath{\C{Commit}} is responsible for finishing the execution of a transaction. When processing a commit, the VM
updates the heap using the write-set if each variable in current thread read-set is equal to its value in the heap.
Otherwise, current transaction should restart.

\[
\begin{array}{l}
  \infer
        {\langle \Theta_h,\sigma,j, t : s \rangle \mapsto_{VM}
         \langle \Theta_h',\sigma',j,t' : s \rangle}
        {\begin{array}{c}
            \sigma' = e : \sigma \\
            t' = \langle \langle exs, c'\rangle, \rho', f, \Theta_r,\Theta_w\rangle\\
            t = \langle \langle exs, \ensuremath{\C{Commit}} : c\rangle,n:\rho,f,\Theta_r,\Theta_w\rangle
         \end{array}} \\ \\
  \langle \Theta_h', c', \rho' , e \rangle
    = \left\{
         \begin{array}{ll}
            \langle \Theta_h \uplus \Theta_w, c, n : \rho, \ensuremath{\C{ICommit}}\,(j-1) \rangle & \text{if }\Theta_r\subseteq \Theta_h\\
            \langle \Theta_h, f, \rho, \ensuremath{\C{IAbort}}\,(j-1) \rangle
         \end{array}
      \right.
\end{array}
\]

Now, we consider instructions used to
support conditionals, \ensuremath{\F{orElse}} and \ensuremath{\F{retry}}. Instructions for compiling conditionals, \ensuremath{\C{Jump}} and \ensuremath{\C{JumpFalse}}, are implemented
using function \ensuremath{\F{jump}} which moves the position of next instruction to be executed accordingly.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{jump}\mathbin{::}\D{Offset}\to \D{Code}\to \D{Code}{}\<[E]%
\\
\>[B]{}\F{jump}\;\V{off}\;(\D{Code}\;\V{os}\;\V{is}){}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\mid \V{off}\mathbin{<}\C{0}\mathrel{=}\D{Code}\;\V{os2}\;(\V{os1}\plus \V{is}){}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\mid \F{otherwise}\mathrel{=}\D{Code}\;(\V{is1}\plus \V{os})\;\V{is2}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\mathkw{where}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\V{off'}\mathrel{=}\F{abs}\;\V{off}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}(\V{is1},\V{is2})\mathrel{=}\F{splitAt}\;\V{off'}\;\V{is}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}(\V{os1},\V{os2})\mathrel{=}\F{splitAt}\;\V{off'}\;\V{os}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In \ensuremath{\F{jump}} definition, whenever an offset \ensuremath{\V{off}} is negative we remove \ensuremath{\V{off}} elements of the \ensuremath{\D{Code}} \ensuremath{\C{executed}} field and
add them to \ensuremath{\C{nexts}} field. When offset is positive we remove from \ensuremath{\C{nexts}} and insert them on \ensuremath{\C{executed}}.

Semantics of \ensuremath{\C{Jump}} and \ensuremath{\C{JumpFalse}} only differ in that the latter jumps only if the topmost element of current
thread local stack is a non-zero integer.
\[
  \begin{array}{l}
     \infer[_{(Jump)}]
           {\langle \Theta_h,\,\sigma,\,j,t : s\rangle \mapsto_{VM}
            \langle \Theta_h,\,\sigma,\,j,t' : s\rangle}
           {\begin{array}{c}
              t = \langle\,\langle exs, \ensuremath{\C{Jump}}\,n : c\rangle,\rho, f, \Theta_r,\Theta_w\rangle \\
              t' = \langle \ensuremath{\F{jump}\;\V{n}}\,\langle exs, \ensuremath{\C{Jump}}\,n : c\rangle, \rho, f, \Theta_r,\Theta_w\rangle
            \end{array}} \\ \\
     \infer[_{(JumpFalse)}]
           {\langle \Theta_h,\,\sigma,\,j,t : s\rangle \mapsto_{VM}
            \langle \Theta_h,\,\sigma,\,j,t' : s\rangle}
           {\begin{array}{c}
              t = \langle\,\langle exs, \ensuremath{\C{JumpFalse}}\,n : c\rangle,m:\rho, f, \Theta_r,\Theta_w\rangle \\
              t' = \langle C, \rho, f, \Theta_r,\Theta_w\rangle \\
              C = \left\{ \begin{array}{cc}
                            \langle \ensuremath{\C{JumpFalse}}\, n:exs,c\rangle & \text{if } m = 0\\
                            \ensuremath{\F{jump}\;\V{n}}\,\langle exs, \ensuremath{\C{Jump}}\,n : c\rangle & \text{otherwise}\\
                          \end{array} \right.
            \end{array}}
  \end{array}
\]
Instruction \ensuremath{\C{Mark}} pushs handler code and \ensuremath{\C{Unmark}} removes a handler from current thread local stack.
\[
   \begin{array}{c}
      \infer[_{(Mark)}]
            {\langle \Theta_h,\,\sigma,\,j,t : s\rangle \mapsto_{VM}
             \langle \Theta_h,\,\sigma,\,j,t' : s\rangle}
            {\begin{array}{c}
               t = \langle\,\langle exs, \ensuremath{\C{Mark}}\,c' : c\rangle,\rho, f, \Theta_r,\Theta_w\rangle \\
               t' = \langle\,\langle \ensuremath{\C{Mark}}\,c' : exs,  c\rangle,c' : \rho, f, \Theta_r,\Theta_w\rangle
             \end{array}} \\ \\
      \infer[_{(Unmark)}]
            {\langle \Theta_h,\,\sigma,\,j,t : s\rangle \mapsto_{VM}
             \langle \Theta_h,\,\sigma,\,j,t' : s\rangle}
            {\begin{array}{c}
               t = \langle\,\langle exs, \ensuremath{\C{Unmark}} : c\rangle,x : c' : \rho, f, \Theta_r,\Theta_w\rangle \\
               t' = \langle\,\langle \ensuremath{\C{Unmark}} : exs,  c\rangle, x: \rho, f, \Theta_r,\Theta_w\rangle
             \end{array}}
   \end{array}
\]
Intuitivelly, when the VM executes a \ensuremath{\C{Retry}} it just looks for a handler code in its stack and executes such code.
To implement such behavior we use functions \ensuremath{\F{handler}}, which searches for a handler on thread's stack and \ensuremath{\F{skip}}, which
removes remaining transaction instructions from threads code, by stopping when it finds a \ensuremath{\C{Unmark}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{handler}\mathbin{::}\D{Stack}\to \D{Code}\to (\D{Code},\D{Stack}){}\<[E]%
\\
\>[B]{}\F{handler}\;[\mskip1.5mu \mskip1.5mu]\;\V{c}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}(\V{c},[\mskip1.5mu \mskip1.5mu]){}\<[E]%
\\
\>[B]{}\F{handler}\;(\C{SVal}\;\anonymous \mathbin{:}\V{s})\;\V{c}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{handler}\;\V{s}\;\V{c}{}\<[E]%
\\
\>[B]{}\F{handler}\;(\C{Han}\;\V{c'}\mathbin{:}\V{s})\;\V{c}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}(\V{c}\;\{\mskip1.5mu \C{nexts}\mathrel{=}(\C{nexts}\;\V{c'})\plus (\C{nexts}\;\V{c})\mskip1.5mu\},\V{s}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{skip}\mathbin{::}\D{Code}\to \D{Code}{}\<[E]%
\\
\>[B]{}\F{skip}\;\V{c}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\D{Code}\;(\C{executed}\;\V{c})\;(\F{skip}\;(\C{nexts}\;\V{c})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{skip}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{skip}\;(\C{Unmark}\mathbin{:}\V{nx})\mathrel{=}\V{nx}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{skip}\;(\C{Mark}\;\anonymous \mathbin{:}\V{nx})\mathrel{=}\F{skip}\;(\F{skip}\;\V{nx}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{skip}\;(\anonymous \mathbin{:}\V{nx})\mathrel{=}\F{skip}\;\V{nx}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Using these functions, the semantics of \ensuremath{\C{Retry}} is immediate. First, we use \ensuremath{\F{skip}} to
remove from threads code the remaining instructions from current transaction and use \ensuremath{\F{handler}}
to add handler code present in stack with the rest of current thread code.
\[
  \begin{array}{c}
     \infer[_{(Retry)}]
            {\langle \Theta_h,\,\sigma,\,j,t : s\rangle \mapsto_{VM}
             \langle \Theta_h,\,\sigma,\,j,t' : s\rangle}
            {\begin{array}{c}
               t' = \langle\,c', \rho', f, \Theta_r,\Theta_w\rangle \\
               \langle c', \rho' \rangle = \ensuremath{\F{handler}}\,\rho\,(\ensuremath{\F{skip}}\, \langle exs, c \rangle)\\
               t = \langle\,\langle exs, \ensuremath{\C{Retry}} : c\rangle,x : c' : \rho, f, \Theta_r,\Theta_w\rangle
             \end{array}}
  \end{array}
\]

\section{Safety Properties}\label{sec:stm-safety}

Several safety conditions for TM were proposed in the literature, such as opacity~\cite{Guerraoui2008},
VWC~\cite{Imbs2009}, TMS1 and TMS2~\cite{Doherty2009} and markability~\cite{LesaniP14}. All these conditions define
indistinguishably criteria and the set of correct histories generated by the execution of TM. In this section, we
present definitions of opacity and markability and describe Haskell implementations of these properties.

Before we give both definition and implementations of these criteria, we need to define some concepts. We say that a transaction
is \emph{live} in a history $H$ if it has no commit or abort registered in $H$, otherwise it is \emph{finished}. A history is said to be \emph{legal}
if all values read after a write in transactional variable are equal to last value written.

\subsection{Opacity}


Intuitively, if a TM algorithm has the opacity property it means that all histories produced by it are legal and
preserves the real time ordering of execution, i.e. if a transaction $T_i$ commits and updates a variable $x$ before
$T_j$ starts then $T_j$ cannot observe that old state of $x$. Guerraoui et.al. define formally opacity and provide a
graph-based characterization of such property in a way that an algorithm is opaque only if the graph built from algorithm
histories structure is acyclic~\cite{Guerraoui2008}. In this work, we use a more direct encoding of opacity by representing it
as a predicate over histories. We implement such predicate as a Haskell function following the textual definition
present in~\cite{Guerraoui2010}.

We say that a TM algorithm is opaque if all prefixes of histories generated by it are final state opaque.
Our Haskell definition of opacity is as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{opacity}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{opacity}\mathrel{=}\F{all}\;\F{finalStateOpacity}\mathbin{\circ}\F{inits}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Function \ensuremath{\F{all}} checks if all elements of input list (second parameter) satisfy a predicate (first paremeter) and
\ensuremath{\F{inits}} returns a list with all prefixes of a given list.

Our next step is to define when a history is final state opaque. We say that a finite history is final state opaque if
exists some completion of it that preserves real time order and all of its transactions are legal.
In Haskell code:


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{finalStateOpacity}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{finalStateOpacity}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{some}\;\F{prop}\mathbin{\circ}\F{completions}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{prop}\;\V{tr}\mathrel{=}\F{preservesOrder}\;\V{tr}\mathrel{\wedge}\F{legal}\;\V{tr}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{some}\;\V{p}\;\V{xs}\mathrel{=}(\F{null}\;\V{xs})\mathrel{\vee}(\F{any}\;\V{p}\;\V{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Function \ensuremath{\F{completions}} produces a list of all completions of a
given history. The completion of a history $H$ is another history $S$, such that:
\begin{itemize}
  \item All live and non-commit pending transactions of $H$ are aborted in $S$; and
  \item All commit pending transactions of $H$ are aborted or committed in $S$.
\end{itemize}
Since in our model we do not consider commit-pending transactions, completion of a history consists of aborting all
live transactions. In order to abort all live transactions we have to split a history in sub-histories that group
operations by transactions. This is done by function \ensuremath{\F{splits}}, which build a map between transaction ids and history items
and return a list of histories, one for each transaction.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{splits}\mathbin{::}\D{History}\to [\mskip1.5mu \D{History}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{splits}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\D{Map}.\F{elems}\mathbin{\circ}\F{foldr}\;\F{step}\;\D{Map}.\F{empty}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{step}\;\V{i}\;\V{ac}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{}\mathrel{=}\F{maybe}\;(\D{Map}.\F{insert}\;(\F{stampOf}\;\V{i})\;[\mskip1.5mu \V{i}\mskip1.5mu]\;\V{ac})\;{}\<[E]%
\\
\>[10]{}\hsindent{8}{}\<[18]%
\>[18]{}(\lambda \V{is}\to \D{Map}.\F{insert}\;(\F{stampOf}\;\V{i})\;{}\<[E]%
\\
\>[18]{}\hsindent{20}{}\<[38]%
\>[38]{}(\V{i}\mathbin{:}\V{is})\;{}\<[E]%
\\
\>[18]{}\hsindent{20}{}\<[38]%
\>[38]{}\V{ac})\;{}\<[E]%
\\
\>[10]{}\hsindent{8}{}\<[18]%
\>[18]{}(\D{Map}.\F{lookup}\;(\F{stampOf}\;\V{i})\;\V{ac}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Using \ensuremath{\F{splits}}, the definition of \ensuremath{\F{completions}} is immediate: we just abort each non-committed transaction and
remove them together with failed ones. Checking if a sub-history for a transaction is comitted or not is a simple
check if the last item of sub-history is equal to \ensuremath{\C{ICommit}} or not.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{completions}\mathbin{::}\D{History}\to [\mskip1.5mu \D{History}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{completions}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{foldr}\;\F{abortLives}\;[\mskip1.5mu \mskip1.5mu]\mathbin{\circ}\F{splits}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{abortLives}\;\V{tr}\;\V{ac}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mid \F{finished}\;\V{tr}\mathrel{=}\V{tr}\mathbin{:}\V{ac}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mid \F{otherwise}\mathrel{=}\V{ac}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{completed}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{completed}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{finished}\mathbin{\circ}\F{last}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{finished}\;(\C{ICommit}\;\anonymous )\mathrel{=}\C{True}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{finished}\;(\C{IAbort}\;\anonymous ){}\<[28]%
\>[28]{}\mathrel{=}\C{True}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{finished}\;\anonymous {}\<[28]%
\>[28]{}\mathrel{=}\C{False}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
To finish the implementation of \ensuremath{\F{finalStateOpacity}}, we need to present definitions of \ensuremath{\F{preservesOrder}} and
\ensuremath{\F{legal}}. The function that verifies if a history preserves \emph{real time ordering} is \ensuremath{\F{preservesOrder}}. Let $t_k$ and
$t_m$ be transactions of some history $H$. We say that $t_k \prec_H t_m$, if whenever $t_k$ is completed and
the last event of $t_k$ precedes the first event of $t_m$ in $H$. A history $H'$ preserves the real time ordering
of $H$ if for all transactions $t_k$ and $t_m$, if $t_k \prec_{H} t_m$ then $t_k \prec_{H'} t_m$. Intuitively,
function \ensuremath{\F{preservesOrder}} checks if transaction ids are ordered according to its position in history. 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{preservesOrder}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{preservesOrder}\;\V{tr}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{and}\;[\mskip1.5mu \V{i}\leq \V{i'}\mid (\V{p},{}\<[26]%
\>[26]{}\V{i}){}\<[30]%
\>[30]{}\leftarrow \V{tr'},{}\<[E]%
\\
\>[3]{}\hsindent{18}{}\<[21]%
\>[21]{}(\V{p'},\V{i'})\leftarrow \V{tr'},{}\<[E]%
\\
\>[3]{}\hsindent{18}{}\<[21]%
\>[21]{}\V{p}\leq \V{p'}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\V{tr'}\mathbin{::}[\mskip1.5mu (\D{Int},\D{Stamp})\mskip1.5mu]{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\V{tr'}\mathrel{=}\F{zipWith}\;\F{step}\;[\mskip1.5mu \C{0}\mathinner{\ldotp\ldotp}\mskip1.5mu]\;\V{tr}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{step}\;\V{p}\;\V{i}\mathrel{=}(\V{p},(\F{stampOf}\;\V{i})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In order to check if all events of a transaction are legal we build a map between variables
and events of read and writing to them using function
\ensuremath{\F{sequentialSpecs}} which, in turn, uses function \ensuremath{\F{readOrWrite}} that returns a variable plus
the event itself or \ensuremath{\C{Nothing}}, if it was not a read or write event.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{readOrWrite}\mathbin{::}\D{Event}\to \D{Maybe}\;(\D{Var},\D{Event}){}\<[E]%
\\
\>[B]{}\F{readOrWrite}\;\V{i}\mathord{@}(\C{IRead}\;\anonymous \;\V{v}\;\anonymous ){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\C{Just}\;(\V{v},\V{i}){}\<[E]%
\\
\>[B]{}\F{readOrWrite}\;\V{i}\mathord{@}(\C{IWrite}\;\anonymous \;\V{v}\;\anonymous ){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\C{Just}\;(\V{v},\V{i}){}\<[E]%
\\
\>[B]{}\F{readOrWrite}\;\anonymous {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\C{Nothing}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{sequentialSpecs}\mathbin{::}\D{History}\to [\mskip1.5mu \D{History}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\F{sequentialSpecs}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\D{Map}.\F{elems}\mathbin{\circ}\V{step1}\mathbin{\circ}\F{mapMaybe}\;\F{readOrWrite}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\V{step1}\mathrel{=}\F{foldr}\;\F{step}\;\D{Map}.\F{empty}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{step}\;(\V{v},\V{i})\;\V{ac}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{}\mathrel{=}\F{maybe}\;(\D{Map}.\F{insert}\;\V{v}\;[\mskip1.5mu \V{i}\mskip1.5mu]\;\V{ac})\;{}\<[E]%
\\
\>[10]{}\hsindent{8}{}\<[18]%
\>[18]{}(\lambda \V{is}\to \D{Map}.\F{insert}\;\V{v}\;(\V{i}\mathbin{:}\V{is})\;\V{ac})\;{}\<[E]%
\\
\>[10]{}\hsindent{8}{}\<[18]%
\>[18]{}(\D{Map}.\F{lookup}\;\V{v}\;\V{ac}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Finally, function \ensuremath{\F{legal}} checks if all values read for a variable are equal to last value written, by
folding over the list of events built for each variable by function \ensuremath{\F{sequentialSpecs}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{legal}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{legal}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{all}\;\F{isLegal}\mathbin{\circ}\F{sequentialSpecs}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{isLegal}\mathrel{=}\F{fst}\mathbin{\circ}\F{foldr}\;\F{step}\;(\C{True},\D{Map}.\F{empty}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{step}\;(\C{IRead}\;\anonymous \;\V{v}\;\V{val})\;(\V{c},\V{m}){}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{}\mathrel{=}\F{maybe}\;(\V{val}\equiv (\D{Val}\;\C{0}),\V{m})\;{}\<[E]%
\\
\>[10]{}\hsindent{8}{}\<[18]%
\>[18]{}((,\V{m})\mathbin{\circ}(\V{c}\mathrel{\wedge})\mathbin{\circ}(\equiv \V{val}))\;{}\<[E]%
\\
\>[10]{}\hsindent{8}{}\<[18]%
\>[18]{}(\D{Map}.\F{lookup}\;\V{v}\;\V{m}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{step}\;(\C{IWrite}\;\anonymous \;\V{v}\;\V{val})\;(\V{c},\V{m}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathrel{=}(\V{c},\D{Map}.\F{insert}\;\V{v}\;\V{val}\;\V{m}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{step}\;\anonymous \;\V{ac}\mathrel{=}\V{ac}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Opacity can be characterized by building a graph over the set of generated histories by a TM algorithm. Such
proof for the TL2 algorithm can be found in~\cite{Guerraoui2010}.

\subsection{Markability}

Another criteria for TM safety is markability~\cite{LesaniP14}, which decomposes opacity in a conjunction of
three invariants, namely: 1) write-observation, which requires that each read operation returns the most current value;
2) read-preservation requires that the read location is not overwritten in the interval that the location is read and
the transaction takes effect and 3) real-time preservation property, already present in opacity. Also,
Lesani et. al.~\cite{LesaniP14} proves that markability is equivalent to opacity.

A history is said to be \emph{final state markable} if there is an extension of it that is write-observant, read-preserving
and preserves real-time. An extension of a history is obtained by committing or aborting its commit-pending transactions
and aborting the other live transactions. Our Haskell implementation of markability is just the conjunction of these
previous properties and uses function \ensuremath{\F{completions}} that generates a list of events grouped by transaction.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{markability}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{markability}\;\V{h}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathrel{=}\F{and}\;[\mskip1.5mu \F{writeObservation}\;\V{h'}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{},\F{readPreservation}\;\V{h'}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{},\F{preservesOrder}\;\V{h'}\mskip1.5mu]{}\<[E]%
\\
\>[11]{}\hsindent{6}{}\<[17]%
\>[17]{}\mathkw{where}{}\<[E]%
\\
\>[17]{}\hsindent{2}{}\<[19]%
\>[19]{}\V{h'}\mathrel{=}\F{concat}\mathbin{\$}\F{completions}\;\V{h}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Function \ensuremath{\F{writeObservation}} checks if a history is write-observant. It builds a mapping between variables
and last values written and traverses the history verifying if subsequent event read the most
recent value written.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{writeObservation}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{writeObservation}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\D{Map}.\F{foldr}\;((\mathrel{\wedge})\mathbin{\circ}\V{snd})\;\C{True}\;\V{m}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\V{m}\mathrel{=}\F{foldr}\;\F{step}\;\D{Map}.\F{empty}\;\V{h}{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\F{step}\;(\C{IRead}\;\anonymous \;\V{v}\;\V{val})\;\V{m}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\mathrel{=}\mathkw{case}\;\D{Map}.\F{lookup}\;\V{v}\;\V{m}\;\mathkw{of}{}\<[E]%
\\
\>[8]{}\hsindent{5}{}\<[13]%
\>[13]{}\C{Nothing}{}\<[23]%
\>[23]{}\to \D{Map}.\F{insert}\;\V{v}\;((\D{Val}\;\C{0}),\C{True})\;\V{m}{}\<[E]%
\\
\>[8]{}\hsindent{5}{}\<[13]%
\>[13]{}\C{Just}\;(\V{val'},\V{ac})\to \D{Map}.\F{insert}\;\V{v}\;(\V{val},\V{ac}\mathrel{\wedge}\V{val}\equiv \V{val'})\;\V{m}{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\F{step}\;(\C{IWrite}\;\anonymous \;\V{v}\;\V{val})\;\V{m}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\mathrel{=}\D{Map}.\F{insert}\;\V{v}\;(\V{val},\C{True})\;\V{m}{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\F{step}\;\anonymous \;\V{ac}\mathrel{=}\V{ac}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The last piece for our implementation of a markability test is function \ensuremath{\F{readPreservation}}, which builds a
mapping between variables and values in order to ensure a value read by a transaction isn't overwritten before
it commits.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{47}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{readPreservation}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{readPreservation}\;\V{h}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{all}\;(\F{fst}\mathbin{\circ}\F{foldr}\;\F{step}\;(\C{True},\D{Map}.\F{empty}))\;\V{h'}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{step}\;(\C{IRead}\;\anonymous \;\V{v}\;\V{val})\;(\V{ac},\V{m}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathrel{=}\mathkw{case}\;\D{Map}.\F{lookup}\;\V{v}\;\V{m}\;\mathkw{of}{}\<[E]%
\\
\>[9]{}\hsindent{5}{}\<[14]%
\>[14]{}\C{Nothing}{}\<[24]%
\>[24]{}\to (\V{ac},\D{Map}.\F{insert}\;\V{v}\;{}\<[47]%
\>[47]{}(\D{Val}\;\C{0})\;\V{m}){}\<[E]%
\\
\>[9]{}\hsindent{5}{}\<[14]%
\>[14]{}\C{Just}\;\V{val'}\to (\V{ac}\mathrel{\wedge}\V{val}\equiv \V{val'},\D{Map}.\F{insert}\;\V{v}\;\V{val'}\;\V{m}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{step}\;(\C{IWrite}\;\anonymous \;\V{v}\;\V{val})\;(\V{ac},\V{m}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathrel{=}\mathkw{case}\;\D{Map}.\F{lookup}\;\V{v}\;\V{m}\;\mathkw{of}{}\<[E]%
\\
\>[9]{}\hsindent{5}{}\<[14]%
\>[14]{}\C{Nothing}{}\<[24]%
\>[24]{}\to (\V{ac},\D{Map}.\F{insert}\;\V{v}\;\V{val}\;\V{m}){}\<[E]%
\\
\>[9]{}\hsindent{5}{}\<[14]%
\>[14]{}\C{Just}\;\V{val'}\to (\V{ac},\V{m}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{step}\;\anonymous \;\V{ac}\mathrel{=}\V{ac}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\V{h'}\mathrel{=}[\mskip1.5mu \V{l}\mid \V{l}\leftarrow \F{splits}\;\V{h}{}\<[E]%
\\
\>[7]{}\hsindent{9}{}\<[16]%
\>[16]{},\F{isCommit}\;(\F{last}\;\V{l})\mskip1.5mu]{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{isCommit}\;(\C{ICommit}\;\anonymous )\mathrel{=}\C{True}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{isCommit}\;\anonymous \mathrel{=}\C{False}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Validation of Semantic Properties}

After the presentation of language semantics and the implementation of
STM safety properties in terms of execution histories, how can we
be sure that the defined semantics enjoys and the compiler preserves these
properties? We follow the lead of~\cite{Hu08} and use QuickCheck~\cite{Claessen00} to
generate random high-level programs and check them against the following properties:

\begin{enumerate}
  \item Does histories produced by TL2-based and STM-Haskell-based semantics have the opacity property?
  \item Does histories by TL2-based and STM-Haskell-based semantics have the markability property?
  \item Does the compiler preserves these safety properties? 
  \item Are the presented semantics equivalent to traditional stop-the-world-semantics for STM?
\end{enumerate}

Each of these properties have been implemented as Haskell functions and tested using QuickCheck for randomly test cases.
Having running many thousands of tests, we gain a high degree of confidence in the safety of our semantics, but it is
important to measure how much of code base is covered by the test suite. Such statistics are provided by Haskell Program Coverage
tool~\cite{Gill2007}. Results of code coverage are presented in the next figure.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.38]{coverage.png}
\caption{Test Coverage Results}
\label{fig:test-coverage}
\end{figure}
While not having 100\% of code coverage, our test suite provides a strong evidence that proposed semantics enjoys
safety properties by exercising on randomly generated programs of increasing size. By analysing test coverage
results, we can observe that code not reached by test cases consists of stuck states on program semantics.

For generating random programs
we use basic generators provided by QuickCheck library and build \ensuremath{\TC{Arbitrary}} instances for \ensuremath{\D{Tran}} and \ensuremath{\D{Proc}} types.
Below, we present a snippet of instance for \ensuremath{\D{Proc}}. Code for \ensuremath{\D{Tran}} follows the same structure.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{instance}\;\TC{Arbitrary}\;\D{Proc}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\F{arbitrary}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathrel{=}\F{sized}\;\F{genProc}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{genProc}\mathbin{::}\D{Int}\to \D{Gen}\;\D{Proc}{}\<[E]%
\\
\>[B]{}\F{genProc}\;\V{n}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \V{n}\leq \C{0}\mathrel{=}\C{PVal}\F{\,\langle\$\rangle\,}\F{arbitrary}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \F{otherwise}{}\<[E]%
\\
\>[4]{}\hsindent{4}{}\<[8]%
\>[8]{}\mathrel{=}\F{frequency}\;{}\<[E]%
\\
\>[8]{}\hsindent{4}{}\<[12]%
\>[12]{}[\mskip1.5mu {}\<[E]%
\\
\>[12]{}\hsindent{2}{}\<[14]%
\>[14]{}(\V{n}\mathbin{+}\C{1},\C{PVal}\F{\,\langle\$\rangle\,}\F{arbitrary}){}\<[E]%
\\
\>[8]{}\hsindent{4}{}\<[12]%
\>[12]{},(\V{n2},\C{PFork}\F{\,\langle\$\rangle\,}\F{genProc}\;(\V{n}\mathbin{-}\C{1})){}\<[E]%
\\
\>[8]{}\hsindent{4}{}\<[12]%
\>[12]{},(\V{n2},\C{PAt}\;\C{Nothing}\F{\,\langle\$\rangle\,}\F{arbitrary}){}\<[E]%
\\
\>[8]{}\hsindent{4}{}\<[12]%
\>[12]{},(\V{n},(\C{\,\oplus_P\,})\F{\,\langle\$\rangle\,}\F{genProc}\;\V{n2}\F{\,\langle *\rangle\,}\F{genProc}\;\V{n2}){}\<[E]%
\\
\>[8]{}\hsindent{4}{}\<[12]%
\>[12]{}\mskip1.5mu]{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\mathkw{where}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\V{n2}\mathrel{=}\F{div}\;\V{n}\;\C{2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The \ensuremath{\F{sized}} function allows for generating values with a size limit and \ensuremath{\F{frequency}} creates a generator
that chooses each alternative with a probability proportional to the accompanying weight.

The TL2-based semantics passed in all tests for safety properties, as expected, since it is well-known
that TL2 provides opacity. But, the semantics based on STM-Haskell does not enjoy such safety properties
since it allows the reading from an inconsistent view of memory. Next example shows how such invalid
memory access can happen.

\begin{Example}
Consider the following program, where \ensuremath{\V{x}} is some variable:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\V{t1}\mathbin{::}\D{Tran}{}\<[E]%
\\
\>[B]{}\V{t1}\mathrel{=}\C{TRead}\;\V{x}\C{\,\oplus_T\,}\C{TRead}\;\V{x}\C{\,\oplus_T\,}\C{TRead}\;\V{x}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\V{t2}\mathbin{::}\D{Tran}{}\<[E]%
\\
\>[B]{}\V{t2}\mathrel{=}\C{TWrite}\;\V{x}\;\V{v}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\V{p}\mathbin{::}\D{Proc}{}\<[E]%
\\
\>[B]{}\V{p}\mathrel{=}\C{Fork}\;(\C{PAt}\;\C{Nothing}\;\V{t1})\C{\,\oplus_P\,}\C{Fork}\;(\C{PAt}\;\C{Nothing}\;\V{t2}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
One of the possible executions of \ensuremath{\V{p}} using STM-Haskell semantics would result in the following
history:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}[\mskip1.5mu \C{IBegin}\;\C{1},\C{IBegin}\;\C{2},\C{IRead}\;\C{1}\;\V{x}\;\C{0}{}\<[E]%
\\
\>[4]{},\C{IWrite}\;\C{2}\;\V{x}\;\C{10},\C{IRead}\;\C{1}\;\V{x}\;\C{0},\C{ICommit}\;\C{2}{}\<[E]%
\\
\>[4]{},\C{IRead}\;\C{1}\;\V{x}\;\C{0},\mathbin{...}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
which violates opacity and markability because it does allow transaction \ensuremath{\V{t1}} to read from an inconsistent
memory view. On TL2 semantics safety is preserved because when transaction \ensuremath{\V{t1}} tries to execute third read
it would be aborted.
\end{Example}

\section{Related Work}\label{sec:related}

\paragraph{Semantics for STM:}
Semantics for STM have been received a considerable attention recently~\cite{Harris05,Abadi2011,Moore2008,Liblit06}.
Harris et al.~\cite{Harris05} defines a stop-the-world operational semantics for STM Haskell.
Essentially, Harris uses a multi-step execution model for transaction execution that does not
allows the investigation of safety property neither how interleaving of transactions happens.
Such approach for STM semantics does not allows the investigation of safety properties in terms
of execution histories, since no interleaving between transactions happen.

Abadi et. al.~\cite{Abadi2011} developed the so-called calculus of automatic mutual exclusion (AME) and
shows how to model the behavior of atomic blocks. Using AME they model STM systems that use
in-place update, optimistic concurrency, lazy-conflict detection and roll-back and determine assumptions
that ensure correctness criteria. As~\cite{Abadi2011}, our work defines
different semantics for the same language with the intent to verify STM algorithms, but they use manual proofs
to assert that their semantics enjoy criteria of interest and our work advocates the use of automated testing
tools to early discover semantic design failures before starting proofs.

Moore et. al.~\cite{Moore2008} proposes a series of languages that model several behaviors of STM. Such
models abstract implementation details and provide high-level definitions. Moore uses small-step operational semantics
to explicitly model interleving execution of threads. Manual proofs of isolation properties are described as a
techinical report~\cite{Moore2008a}.

\paragraph{Safety properties for STM:} Safety criteria for STM was another line of research pursued
recently~\cite{LesaniP14,Guerraoui2008}. Opacity was defined by Guerraoui et. al.~\cite{Guerraoui2008}
and it is described as a condition on generated histories by a TM algorithm and provide a graph-based
characterization of opacity. Such graph is built from histories and an algorithm is considered opaque if
the corresponding graph is acyclic for every possible history. Lesani et. al.~\cite{LesaniP14} describes
an equivalent safety property called markability, which decomposes opacity in three invariants and prove
that these invariants are equivalent to opacity. 


\paragraph{Formal verification of STM:} Formal verification of STM algorithms has been an active subject
of recent research~\cite{Lesani2012,CohenPZ08,cohen2007,Guerraoui2008a,Lesani2013}. Lehsani et.al.~\cite{Lesani2012}
describes a PVS~\cite{Owre1992} formalization of a framework for verifying STM algorithms based on I/O automata. The
main idea of Lehsani's framework is to represent both specifications and algorithms as automata and their equivalence is
verified by proving a simulation relation between these automata. The use of model checker to verify TM algorithms was
the subject of~\cite{CohenPZ08,cohen2007}. Both works use the specification languages of model checkers~\cite{Lamport2002}
to describe STM implementations and check them against safety properties. 
We leave using proof assistants for verifying safety properties of our STM semantics for future work.


\paragraph{Testing algorithms for STM:} Automated testing for a compiler of a STM high-level language to
a virtual machine was the subject of~\cite{Hu08}. He uses QuickCheck to generate random high-level STM
programs and check that their virtual machine compiler preserves the semantics of source programs. Unlike our work that
focus on verifying safety of algorithms expressed as small-step operational semantics, Hu et. al. concerns only with
semantic preservation of compilation process and uses multi-steps to evaluate transactions in a stop-the-world semantics for
their high-level language. While such semantics design choices are reasonable for verifying a semantic preservation theorem for a compiler,
they do allow for checking safety properties. Harmanci et. al.~\cite{Harmanci2009} describes a tool for testing
TM algorithms, called TM-unit. Using TM-unit domain specific language, users can specify TM workloads for both
safety and performance testing of TM algorithms. Authors argue that their domain specific language is simple and
expressive but no formal semantics of this language is provided. We believe that the use of domain specific languages
is invaluable to provide concise and formal specifications of STM algorithm and we leave this line of research for
further work.

\section{Conclusion}\label{sec:conclusion}

In this work we presented safe semantics for a simplied high-level language with STM support and use
property based testing to verify it. The lightweight approach provided by QuickCheck allow us to experiment
with different semantic designs and implementations, and to quickly check any changes. During the development of this work,
we have changed our basic definitions many times, both as a result of correcting errors, and streamlining the presentation.
Ensuring that our changes were consistent was simply a matter of re-running test suite. Encoding safety properties as
Haskell functions over STM histories provides a clean and concise implementation that helps not only to fix semantics
but also to improve our understanding of STM algorithms.

As future work we intend to use Agda~\cite{Norell2009} to provide formally certified proofs that the presented semantics does
enjoy safety properties and also investigate the usage of domain specific languages to ease the task of specifying algorithms
as small-step operational semantics of a simple transactional language.

\section{References}

\bibliographystyle{elsarticle-num}
\bibliography{references} 

\end{document}
