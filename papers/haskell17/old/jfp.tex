% This is file JFP2egui.tex
% release v1.02, 27th September 2001
%   (based on JFPguide.tex v1.11 for LaTeX 2.09)
% Copyright (C) 2001 Cambridge University Press

\NeedsTeXFormat{LaTeX2e}

\documentclass{jfp1}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{proof}
\usepackage{amssymb}

\newcommand{\Fork}{\textit{fork }}
\newcommand{\Atomic}{\textit{Atomic }}
\newcommand{\Read}{\textit{readTVar }}
\newcommand{\Write}{\textit{writeTVar }}
\newcommand{\If}{\textit{if }}
\newcommand{\Then}{\textit{ then }}
\newcommand{\Else}{\textit{ else }}
\newcommand{\Retry}{\textit{retry}}
\newcommand{\OrElse}{\textit{ orElse }}
\newcommand{\Begin}{\textit{{Begin }}}
\newcommand{\Commit}{\textit{{Commit }}}
\newcommand{\Abort}{\text{{\it Abort \/}}}
\newcommand{\EvalCtxTran}[1]{\ensuremath{\mathbb{T}[#1]}}
\newcommand{\EvalCtxProc}[1]{\ensuremath{\mathbb{P}[#1]}}
\newcommand{\TStep}[9]{\ensuremath{\langle  #2, #3, #4 \rangle
    \mapsto_{T_{#5}} \langle  #7, #8, #9 \rangle}}
\newcommand{\TStepClos}[9]{\ensuremath{\langle #2, #3, #4 \rangle
    \mapsto^{\star}_{T_{#5}} \langle #7, #8, #9 \rangle}}
\newcommand{\TranStepClos}[4]{\ensuremath{\langle #1 , #2 \rangle
    \mapsto^{\star}_{T} \langle #3, #4 \rangle}}
\newcommand{\ProcStep}[8]{\ensuremath{\langle #1 , #2, #3,#4 \rangle
    \mapsto_{P} \langle #5, #6, #7, #8 \rangle}}
\newcommand{\SimpleStep}[4]{\ensuremath{\langle #1 , #2 \rangle
    \mapsto_{SM} \langle #3, #4 \rangle}}


\title[Journal of Functional Programming]
      {Towards a Verified Opaque Semantics for Software Transactional Memory}

 \author[R. Ribeiro]
        {RODRIGO RIBEIRO \\
         Universidade Federal de Ouro Preto, Minas Gerais, Brazil\\
         \email{rodrigo@decsi.ufop.br}}

\author[A. Du Bois]
       {ANDR\'E RAUBER DU BOIS\\
        Universidade Federal de Pelotas, Rio Grande do Sul, Brazil\\
        \email{dubois@inf.ufpel.br}}

%\jdate{September 2001, update April 2007}
%\pubyear{2001}
%\pagerange{\pageref{firstpage}--\pageref{lastpage}}
%\doi{S0956796801004857}

\newtheorem{lemma}{Lemma}[section]

\begin{document}

\label{firstpage}

\maketitle

\begin{abstract}
Here goes the abstract...
\end{abstract}

%\tableofcontents

\section{Introduction}

It is a well known fact that writing correct lock based concurrent
programs is a painful task, since locks doesn't scale~\cite{Harris05}.
\emph{Software Transactional Memory} (STM) is a promising approach to
write concurrent software since it can perform groups of memory
operations atomically~\cite{Shavit95} thus providing automatic
rollback, deadlock, priority inversion and lock granularity freedom.

Haskell's implementation of STM pioneered, thought its type system,
the strict separation between transactional and non-transactional
code and its interface allows the compositional definition of 
transactions~\cite{Harris05}, which executes sequences of read 
and write operations on memory \emph{atomically}.

While STM provides a simple yet powerful mechanism to write concurrent
applications, its implementation is far from trivial. Several
algorithms for transactional memories (see e.g.~\cite{Dice06}) have
been proposed and also some correctness criteria~\cite{LesaniP14,Guerraoui2008}.

eases the development of concurrent applications since it
frees the programmer from worring with synchronization between
different threads.

Talk about models / semantics of STM. Mention Hutton work.

More specifically, our contributions are:

\begin{itemize}
   \item We define a trace-based small step semantics for a high-level 
             language with STM support.
   \item We show that our trace-based small step semantics is
             equivalent to the traditional stop-the-world semantics~\cite{Hu09}.      
   \item A Haskell implementation of opacity property for traces
             generated by proposed language semantics and its verification
             using QuickCheck~\cite{Claessen00}.
    \item A compiler from the high-level language to a transactional
             stack-machine and show that compiled programs preserve
             opacity.
\end{itemize}

Our work shares some similarities with~\cite{Hu09}: We use a small
variation of its reduced language for STM, but our focus is on 
verifying a safety property:namely, opacity~\cite{Guerraoui2008} for STM,
and show that instead of a compiler correctness theorem for transactional virtual 
machine.


\section{A Model for Software Transactional Memory}

In Harris et al.~\cite{Harris05} describes  transactional memory an
extension to the Glasgow Haskell Compiler. 
Thanks to Haskell's type system and its monadic programming support, 
transactions are defined in a monad 
Notable is the fact that no modification to the Haskell language specification was necessary: its higher-order constructs are suf- ficient to implement the required control structures, whereas previous attempts [6] made changes to the language syntax.
The standard Haskell approach to sequencing read and write operations on memory is to use the IO monad to handle sequencing, and IORefs to represent mutable variables. STM Haskell provides analogous operations on TVars (trans- actional variables) within the STM monad:



In order to analyse a semantics for a high level language with
transactional memory support, we follow the same approach used
by~\cite{Hu08}: defining a simple language of integer-valued 
expressions (e.g. Figure~\ref{fig:syntax}) extended with conditionals,
$\OrElse$ and $\Retry$ constructs. 

We let meta-variable $v$ denote integer constants and $x$ 
(transactional) variables. 

\begin{figure}[h]
  \[
        \begin{array}{ll}
             \begin{array}{lcl}
             p & ::=    & v   \\                                        
                & \mid & \Fork\:p   \\
                & \mid & \Atomic\:t   \\                         
                & \mid & p \oplus p       \\                     
             \end{array} 
             &
             \begin{array}{lcl}
             t  & ::=    & v  \\
                & \mid & \Read\:x \\
                & \mid & \Write\:x\:\:t \\
                & \mid & t \oplus t \\
                & \mid & \If\: t\: \Then t \: \Else\: t \\
                & \mid & \Retry \\
                & \mid & t\: \OrElse\: t \\
             \end{array}                
        \end{array}
  \]
  \centering
  \caption{Language syntax.}
  \label{fig:syntax}
\end{figure}

In our semantics, we use finite maps to 
represent heaps and logs used by transactions (i.e. read and write
sets). Notation $\bullet$ denotes an empty finite mapping.
Variable $\Theta$ represents a triple formed by a heap, read and
write set used by some transaction $t$. We represent read and write
sets and the heap by $\Theta_r$, $\Theta_w$ and $\Theta_h$
respectively. Let $h(x)$ denotes the operation
of retrieving the value associated with key $x$ in finite mapping 
$h$ and $h(x)=\bot$ denotes that no value is associated
with $x$.
Notation $h \uplus h'$ denotes the right-biased union of 
two finite mappings, i.e. when both maps have the same key $x$, we keep
the value $h'(x)$. Following common
practice, notation $h\,[x\mapsto v]$ denotes
finite mapping update, i.e. finite mapping $h'$ such that:
1) $h'(x) = v$ and 2) $h'(y) = h(y)$, for $x \neq y$.

The proposed semantics is based on Transactional Locking 2 
algorithm (TL2)~\cite{Dice06}. We define it using a small-step 
semantics defined in Figures~\ref{fig:small-step-transactions} 
and~\ref{fig:small-step-processes}. We use evaluation contexts, which
are defined in Figure~\ref{fig:hole-syntax}, to avoid the need of 
``congruence'' rules in semantics.

\begin{figure}[h]
        \[
              \begin{array}{c}
                   \textit{Evaluation contexts for transactions} \\
                   \\
                   \begin{array}{rcl}
                      \EvalCtxTran{\cdot} & ::=    & \Write x\:\EvalCtxTran{\cdot}\\
                                                      & \mid &\EvalCtxTran{\cdot}\:\oplus t\\
                                                      & \mid & v\oplus\EvalCtxTran{\cdot}\\
                                                      & \mid &\If\:\EvalCtxTran{\cdot}\:\Then\:t\:\Else\:t'
                   \end{array}
                    \\
                \\
                    \textit{Evaluation contexts for processes}\\
                    \\
                    \begin{array}{rcl}
                      \EvalCtxProc{\cdot} & ::=    & \Fork\:\EvalCtxProc{\cdot}\\
                                                      & \mid &\EvalCtxProc{\cdot}\:\oplus t\\
                                                      & \mid & t\oplus\EvalCtxProc{\cdot}\\
                    \end{array}
              \end{array}
        \]
        \centering
        \caption{Evaluation contexts for high-level language.}
        \label{fig:hole-syntax}
     \end{figure}

Informally, TL2 algorithm works as follows: threads execute reads and
writes to objects, but no memory locations are actually modified. All 
writes and reads are recorded in write and read logs. When a
transaction finishes, it validates its log to check if it has seen a 
consistent view of memory, and its changes are committed to memory.

     \begin{figure}[h]
         \[
               \Theta(x,i) = \left\{
                      \begin{array}{ll}
                           (v,\Theta) & \textit{if } \Theta_w(x) = v\\
                           (v,\Theta) & \textit{if } \Theta_w(x) = \bot,
                                        \Theta_r(x) \neq \bot, 
                                        \Theta_h(x) = (i',v)
                                        \textit{ and } i \geq i'\\
                           (v, \Theta_r\,[x \mapsto v]) & 
                                  \textit{if } \Theta_w(x) =
                                                  \Theta_r(x) = \bot,\,
                                  \Theta_h(x) = (i',v),
                                     \textit{ and } i \geq i' \\
                           \Retry & \textit{if } \Theta_h(x) = (i',v)
                                    \textit{ and } i < i'
                      \end{array}
                                  \right.
         \]
         \centering
         \caption{Reading a variable}
         \label{fig:readvar}
     \end{figure}

     Verifying consistency of a transaction.

     \begin{figure}[h]
        \[
          consistent(\Theta,i) = \forall x. \Theta_r(x) = (i,v) \to
          \Theta_h(x) = (i',v) \land i \geq i'
        \]
        \centering
        \caption{Predicate for consistency of transaction logs}
        \label{fig:consistency}
     \end{figure}

     \begin{figure}[h]
         \[
             \begin{array}{c}
                  \fbox{$\TStep{h}{\Theta}{\sigma}{t}{i}{h'}{\Theta'}{\sigma'}{t'}$} \\
                   \\
                  \begin{array}{ccc}
                      \infer[_{(Context)}]
                              {\TStep{h}{\Theta}{\sigma}{\EvalCtxTran{t}}{i}{h'}{\Theta'}{\sigma'}{\EvalCtxTran{t'}}}
                              {\TStep{h}{\Theta}{\sigma}{t}{i}{h'}{\Theta'}{\sigma'}{t'}} & \:\:\:\:\: & 
                     \infer[_{(Write)}]
                              {\TStep{h}{\Theta}{\sigma}{\Write\:x\:v}{i}{h}{\Theta_{w}[x
                                                                                                         \mapsto
                                                                                                         v]}{\sigma'}{t'}}
                              {\sigma' = Write\:i\:x\:v :: \sigma} \\ \\
                    \infer[_{(WriteRetry)}]    
                             {\TStep{h}{\Theta}{\sigma}{\Write\:x\:\Retry}{i}{h}{\Theta}{\sigma'}{\Retry}}
                             {\sigma' = Abort\:i\, :: \sigma} & &                     
                    \infer[_{(ReadVal)}]
                             {\TStep{h}{\Theta}{\sigma}{\Read\:x}{i}{h}{\Theta'}{\sigma'}{v}}
                             {\sigma' = Read\:i\:x\:\:v \,:: \sigma & 
                              (v,\Theta') = \Theta(x,i) } \\ \\
                    \infer[_{(ReadRetry)}]    
                             {\TStep{h}{\Theta}{\sigma}{\Read\:x}{i}{h}{\Theta}{\sigma'}{\Retry}}
                             {\sigma' = Abort\:i\, :: \sigma & 
                              \Retry = \Theta(x,i)}  & &
                    \infer[_{(Plus)}]
                             {\TStep{h}{\Theta}{\sigma}{v \oplus
                                                         v'}{i}{h}{\Theta}{\sigma}{v
                                                       + v'}}
                             {} \\ \\
                    \infer[_{(OrElseVal)}]
                             {\TStep{h}{\Theta}{\sigma}{t \OrElse t'}{i}{h'}{\Theta'}{\sigma'}{v}}
                             {\TStepClos{h}{\Theta}{\sigma}{t}{i}{h}{\Theta'}{\sigma'}{v}}
                             & &
                    \infer[_{(OrElseRetry)}]
                             {\TStep{h}{\Theta}{\sigma}{t \OrElse t'}{i}{h'}{\Theta'}{\sigma'}{t'}}
                             {\TStepClos{h}{\Theta}{\sigma}{t}{i}{h}{\Theta'}{\sigma'}{\Retry}}                              
                    \\ \\ 
                    \infer[_{(PlusRetryL)}]
                             {\TStep{h}{\Theta}{\sigma}{\Retry \oplus t}{i}{h}{\Theta}{\sigma'}{\Retry}}
                             {\sigma' = Abort\:i :: \sigma} & &
                    \infer[_{(PlusRetryR)}]
                             {\TStep{h}{\Theta}{\sigma}{t \oplus \Retry}{i}{h}{\Theta}{\sigma'}{\Retry}}
                             {\sigma' = Abort\:i :: \sigma} \\ \\
                    \multicolumn{3}{c}{
                    \infer[_{(IfZero)}]
                             {\TStep{h}{\Theta}{\sigma}{\If v = 0
                    \Then t \Else t'}{i}{h}{\Theta}{\sigma}{t}}{}}
                    \\
                    \\
                    \multicolumn{3}{c}{
                    \infer[_{(IfNonZero)}]
                             {\TStep{h}{\Theta}{\sigma}{\If v \neq 0
                    \Then t \Else t'}{i}{h}{\Theta}{\sigma}{t'}}{}} \\
                    \\
                    \multicolumn{3}{c}{
                    \infer[_{(IfRetry)}]
                             {\TStep{h}{\Theta}{\sigma}{\If \Retry
                    \Then t \Else t'}{i}{h}{\Theta}{\sigma'}{\Retry}}
                    {\sigma' = Abort\:i :: \sigma}} 
                  \end{array}
             \end{array}
         \]
         \centering
         \caption{Small-step operational semantics for transactions.}
         \label{fig:small-step-transactions}
     \end{figure}


     \begin{figure}[h]
       \[
            \begin{array}{c}
               \fbox{$\TStepClos{h}{\Theta}{\sigma}{t}{i}{h'}{\Theta'}{\sigma'}{t'}$}
               \\ \\
               \begin{array}{c}
                 \infer[_{(TRefl)}]
                          {\TStepClos{h}{\Theta}{\sigma}{t}{i}{h}{\Theta}{\sigma}{t}}{}
                          \\ \\
                 \infer[_{(TTran)}]
                          {\TStepClos{h}{\Theta}{\sigma}{t}{i}{h}{\Theta'}{\sigma'}{t'}}
                          {\TStep{h}{\Theta}{\sigma}{t}{i}{h}{\Theta_1}{\sigma_1}{t_1}
                           & 
                           \TStepClos{h}{\Theta_1}{\sigma_1}{t_1}{i}{h}{\Theta'}{\sigma'}{t'}}               
               \end{array}  
             \end{array}
       \]
       \centering
       \caption{Reflexive-transitive closure of transaction small step
       semantics.}
       \label{fig:clos-transaction}
     \end{figure}

     Now the small step semantics for processes

     \begin{figure}[h]
        \[
             \begin{array}{c}
                  \fbox{\ProcStep{h}{\sigma}{i}{s}{h'}{\sigma'}{i'}{s'}} \\ \\
                  \begin{array}{ccc}
                      \infer[_{(Preempt)}]
                               {\ProcStep{h}{\sigma}{i}{p:s}{h'}{\sigma'}{i'}{p : s'}}
                               {\ProcStep{h}{\sigma}{i}{s}{h'}{\sigma'}{i'}{s'}} & \:\:\:\: &
                      \infer[_{(Context)}]
                               {\ProcStep{h}{\sigma}{i}{\EvalCtxProc{p} : s}{h'}{\sigma'}{i}{\EvalCtxProc{p'}:s}}                                       
                               {\ProcStep{h}{\sigma}{i}{p : s}{h'}{\sigma'}{i'}{p':s'}} \\ \\                                       
                    \infer[_{(Plus)}]
                             {\ProcStep{h}{\sigma}{i}{v \oplus v' : s}{h}{\sigma}{i}{v + v'
                    : s}}
                             {} & & 
                    \infer[_{(Fork)}]
                             {\ProcStep{h}{\sigma}{i}{\Fork p : s}{h}{\sigma}{i}{0 : p :
                                                  s}}{}\\ \\
                    \multicolumn{3}{c}{
                    \infer[_{(AtomicVal)}]
                             {\ProcStep{h}{\sigma}{i}{\Atomic t :
                    s}{h'}{\sigma'}{i + 1}{v : s}}
                             {
                               consistent(\Theta',i) &
                               h' = h \uplus \Theta_w &
                                \TStepClos{h}{(h,\bullet,\bullet)}{\sigma}{t}{i}{h}{\Theta'}{\sigma'}{v}
                                }}\\ \\
                    \infer[_{(AtomicRetry)}]
                              {\ProcStep{h}{\sigma}{i}{\Atomic t : s}{\sigma'}{i}{h}{0 : s}}                                
                              {\TStepClos{h}{(h,\bullet,\bullet)}{\sigma}{t}{i}{h}{\Theta'}{\sigma'}{\Retry}}
                              & &
                    \infer[_{(AtomicNon)}]
                             {\ProcStep{h}{\sigma}{i}{\Atomic t :
                                  s}{\sigma'}{i}{h}{0 : s}}
                             {\TStepClos{h}{(h,\bullet,\bullet)}{\sigma}{t}{i}{h}{\Theta'}{\sigma'}{t'}
                                  & 
                             \neg\,consistent(\Theta',i)}     
                  \end{array}
             \end{array}
        \]
        \centering
        \caption{Small-step operational semantics for processes.}
        \label{fig:small-step-processes}
     \end{figure}

\bibliographystyle{jfp}
\bibliography{references}

\label{lastpage}

\end{document}

% end of JFP2egui.tex
