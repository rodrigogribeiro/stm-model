
----------------------- REVIEW 1 ---------------------
PAPER: 24
TITLE: A Property Based Testing Approach for Software Transactional Memory Safety
AUTHORS: Rodrigo Geraldo Ribeiro and Andre Rauber Du Bois

Overall evaluation: -2 (reject)

----------- Overall evaluation -----------
This is a review of the updated version of the paper, which was renamed to
"A Property Based Testing Approach for Soâ€¦ware Transactional Memory Safety".

Overall, I found the paper somewhat hard to read: I think that it should be restructured to
start by explaining the properties that we are interested in
verifying, and then present all the machinery used to do so.
Also I felt that the paper doesn't have a clear stated purpose:  most
of the content is concerned with the development of various semantics,
and at the end there is just a little bit about testing.
While the authors claim that the semantics should be useful for people
who want to experiment with different STM implementations,
the paper does not prevent a framework to help do so.  If I was to
develop a new STM implementation,
what parts of the paper would I reuse, and what new parts would I have
to provide?
************************
>> The objective of the paper is to give an approach for testing
new STM algorithms w.r.t. safety properties. The whole approach
could be reused, but the code for semantic and code for properties tested
are specific. If a user want to test a new STM algorithm developed by
him, it will need to specify it as a small-step semantics and test
it. 

Mention that test properties could be reused.

************************

Finally, I found the testing section underwhelming:  it is not clear what was tested, and there was basically no results reported.   So what did we "verify" in the end?

>> We test safety properties for STM, namely markability and
   opacity. We report on code coverage obtained by such tests.

************************

Below are just some notes I was taking as I was reading the paper---I hope they might be useful in improving future iterations of the work.


Section 2:

p1. Transfer example: why retry if not enough money??

>> Classic example for STM.

Section 3:
What are opacity and markability?

>> I believe that we have explained both properties.

3.1 "but they interesting" -> "but they ARE interesting"

>> OK

Section 3.1
Using addition for sequencing is quite strange.
At first I thought that this is just notation in the
syntax, but the comments make it sound like we are
actually using addition?  Without more context it is hard
to know how that makes sense.

>> It's well known that monads are just monoids in the category of
   endofunctors. We limit ourselves to addition for sequencing just
   to avoid issues with name binding, since addition could be used
   to sequence computations as monads (addition form a monoid for integers).
   

I am unclear of how to model two writes one after the other.

>> Non sense: TWrite x (TVal 1) :+: TWrite y (TVal 2)

"an value" -> "a value"

>> OK

"4-uple" -> "4-tuple"

>> OK

Section 3.2
I find it odd that the paper all of a sudden switched
to math notation.  Since we are going to be doing testing
based on this semantics, I imagine there is Haskell
code implementing the steps...

>> We use math notation because it provides a concise
definition of semantics. Using Haskell code would, in our view,
clutter presentation unnecessarially.

Section 5

This Section needs to be much earlier in the paper:
after all it gives the motivation of why we are doing
all the rest!

Also, in this section I found the short bits of Haskell
code much more informative than the English text.

Section 6

It would have been nice to see the properties tested.

>> Ok. I'll put it explicitly on the paper.

The testing procedure used should be more clear.
For example, there is a figure showing coverage
metrics, but coverage of what?

>> Ok, I'll put it explicitly

Also, coverage does
not seem like a good metric for testing concurrency
properties as it depends on the timing of the code,
not so much which bits are executed.

>> Timing? I do not understand this...


----------------------- REVIEW 2 ---------------------
PAPER: 24
TITLE: A Property Based Testing Approach for Software Transactional Memory Safety
AUTHORS: Rodrigo Geraldo Ribeiro and Andre Rauber Du Bois

Overall evaluation: -2 (reject)

----------- Overall evaluation -----------
This paper defines a small-step semantics for Software Transactional
Memory, providing two variants:
one that captures the Transactional Locking 2 STM algorithm and one
that more closely resembles the STM support available in Haskell.
To evaluate the correctness of their semantics with respect to the STM
safety properties of opacity and markability,
the authors reuse the techniques presented in [20], defining a small
language
containing STM operations and a compiler from that language to a
simple virtual machine. They apply QuickCheck to validate their desired safety properties in this environment.

Since the original submission, the authors added introductory text
that elaborates on the difference between
their work and prior work on STM semantics.
They claim to be the first truly small-step semantics that
covers both orElse and retry.  They also expanded the discussion of
their QuickCheck evaluation and consolidated the discussion of the
opacity and markability properties in Section 5.

The changes in this submission make for a better presentation of the
authors' work.  However, they still do not clearly articulate the
importance of their contribution. What is the significance of a "truly
small-step" semantics over one that encodes
orElse and retry as "multi-steps"?

>> Ok. It explained the reason for atomic and not for orElse. I'll
   write it explicitly on paper. Mention that such multi-steps does
   not allow for checking when interleaving transactions interfere
   with each other.

What benefit to reasoning or correctness do you achieve with this new
semantics?  What insights have you gained through your approach?
As presented, the research delta over prior work appears too small
to warrant publication.

>> Well, I do not agree with this, since our paper is *very* different
from Hu and Hutton et al and other papers covering STM semantics.

The coverage statistics provided in Section 6 are an improvement over
the previous version, though it would be nice if more text were
devoted to explaining the coverage gaps.

>> I agree. I'll explain this gaps better in text in order to justify them.

The Arbitrary instance is not given enough context to help the reader
understand what has been demonstrated via testing.

>> Probably, I need to articulate how such arbitrary instance is used
     to generate random programs.

The opacity and markability properties are better explained than in
the prior version, but there is still not any context given about
why these properties are interesting.

>> Relate efficiency and safety properties. Relate correctness of
   client code and safety properties.

The paper states that there are many safety properties of STM
discussed in the literature. Why are these two of note?

>> Well... I do not know how to answer this.

What are the consequences of STM-Haskell not having the opacity
property?

>> This is explained in the paper introduction:

Such correctness concerns are not just formalization curiosity, they can influence directly on implementation efficiency.
Le et.al.~\cite{Le2016} mention that current STM-Haskell implementation does not enjoy opacity and that it
can cause threads to loop, due to accessing an inconsistent memory view. To avoid such problems STM-Haskell
implementation validates the read set each time a thread is scheduled and such checking overhead can cause
a waste of execution time. This is one of the motivation for Le et. al.~\cite{Le2016} proposing a new
implementation of STM-Haskell using the Transaction Locking II (TL2) algorithm~\cite{Dice06}. 


I recommend that this paper be rejected.


----------------------- REVIEW 3 ---------------------
PAPER: 24
TITLE: A Property Based Testing Approach for Software Transactional Memory Safety
AUTHORS: Rodrigo Geraldo Ribeiro and Andre Rauber Du Bois

Overall evaluation: 0 (borderline paper)

----------- Overall evaluation -----------
-------
