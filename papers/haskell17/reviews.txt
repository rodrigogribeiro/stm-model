---------------------- REVIEW 1 ---------------------
PAPER: 1
TITLE: An Opaque Model for Software Transactional Memory for Haskell
AUTHORS: Rodrigo Ribeiro and André Du Bois

Overall evaluation: -2 (reject)

----------- Overall evaluation -----------
This paper defines a small-step semantics for Software Transactional Memory, providing two variants: one that captures the Transactional Locking 2 STM algorithm and one that more closely resembles the STM support available in Haskell.  To evaluate the correctness of their semantics with respect to the STM safety properties of opacity and markability, the authors reuse the techniques presented in [20], defining a small language containing STM operations and a compiler from that language to a simple virtual machine.  They apply QuickCheck to validate their desired safety properties in this environment.

Defining a small-step semantics for STM is an important step on the path towards formally verifying STM algorithms.  Unfortunately, the authors failed to clearly articulate the value of their approach over the extensive previous work in this area.  What benefit does the approach presented in the paper have over using an existing semantics for STM or an alternative method of evaluating STM correctness such as model checking?  Given that the paper's work has substantial overlap with [20], the authors should more explicitly cover the value added by this work.  For example, the paper states that previous work does not provide a semantics for orElse or retry, but does not specify what new insights they gain into STM correctness by including these constructs.

A further problem with the paper is the evaluation using QuickCheck.  This evaluation is purported to be one of the main contributions of the paper, but there is not enough information provided to enable the reader to glean any insight from the evaluation.  The authors state the properties checked only informally and limit the description of the tests performed to stating that they ran "a large number of random test cases".  What methodology was employed to give us any confidence that the set of random tests provide reasonable coverage?  In the conclusions, the authors mention the value of the test suite in finding bugs in their model - perhaps including one such example would help to illustrate the value of the test suite to the reader.  Regarding the safety properties checked, the authors provide an overview of the two safety properties, but do not give any context as to why they chose these safety properties and whether they are sufficient to determine STM correctness.

The presentation of the paper could use some improvement.  Though the paper has the word "Opaque" in the title, the definition of opacity is not given until Section 5.  A high-level meaning for this property should be given when the term is first used.  The paper also contains MANY typos and would benefit by being run through a spelling and grammar checker.

I recommend that this paper be rejected.

Minor comments:

Abstract
"with locks" -> "about locks"
Such [a] programming model
"grealy" -> "greatly"

Section 1
where -> were col2 p1
[to] certify

Section 2
TM design space -> STM design space (paper only examines STM)
a STM -> an STM

Section 3
- a aborted -> an aborted
- aren't -> are not
- they [are] interesting
- "built using Nothing to denote that such block have started its execution"
    Do you mean that no block has started its execution?
- as it where -> as if they were
- differ -> differentiate
- "no sufficient resources" -> "not sufficient resources"
- slighly -> slightly
- What does "transactions aborted by inconsistent views should not be "catched" by an orElse" mean?
- Issues in example
    TIf (v [< i])
    TRetry in TWrite?
- used to -> used for

Section 3.2.1
- This is the first expansion of TL2 acronym.  Should introduce at first reference.

Section 3.2.2
- auxiliar -> auxiliary
- semantic -> semantics
- indistinguishably criteria does not make sense, not sure what is meant

Section 5.1
- exists -> there exists
- in sub-histories -> into subhistories
- Disconnect between exposition and code. preservesOrder is explained in terms of a comparison of two histories, but the preservesOrder function is of a single history.

Section 5.3
- preserves -> preserve

Section 6
- [20] He -> They
- focus -> focuses


----------------------- REVIEW 2 ---------------------
PAPER: 1
TITLE: An Opaque Model for Software Transactional Memory for Haskell
AUTHORS: Rodrigo Ribeiro and André Du Bois

Overall evaluation: 0 (borderline paper)

----------- Overall evaluation -----------
This paper introduces a lightweight, operational semantics model for software transactional memory (STM) in Haskell. The authors sais that these are first step towards building a STM with a safety proof. From a Haskell user's point of view, I have used STM when necessarily. I understand the value of STM, and the value of proof. If the authors could elaborate on the value of their work to the STM users, especially by showing how existing STM model may fail and how their model can detect and fix the problem, the paper will be even more attractive to wide range of readers.


----------------------- REVIEW 3 ---------------------
PAPER: 1
TITLE: An Opaque Model for Software Transactional Memory for Haskell
AUTHORS: Rodrigo Ribeiro and André Du Bois

Overall evaluation: -2 (reject)

----------- Overall evaluation -----------
Abstract:
Exemplify the safety properties you're looking to verify.

Introduction:
"However, certify" -> "However, to certify"

"proving non-opacity", what does this mean.  It's the first time you mention non-opacity.

You never explai  what opacity and markability are.

Section 3.1:
"catched" -> "caught"

You need to explain how changing monadic bind to addition makes any sense.

Example 1 makes no sense to me.
The original code uses 'v < i', the translation uses 'v'.
The translation uses 'v - i', but there is abstract syntax for -
In nonBlockGetR the getR is used both when returning 1 and 0.
What does 'let' mean?  It's not paft ob the translation syntax.

Section 5.
Examples please!  The opacity definition is quite opaque. :)

I don't find the mixture of mathematical notation and Haskell helpful.
If you're given real Haskell code, I might have been able to understand it.
If you'd used good mathematical notation I might have been able to understand it.
Now it's a strange mix.
