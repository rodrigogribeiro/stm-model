\documentclass[14pt]{beamer}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{proof}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}


\newcommand{\EvalCtxTran}[1]{\ensuremath{\mathbb{T}[#1]}}
\newcommand{\EvalCtxProc}[1]{\ensuremath{\mathbb{P}[#1]}}

\usepackage{color}
\newcommand{\redFG}[1]{\textcolor[rgb]{0.6,0,0}{#1}}
\newcommand{\greenFG}[1]{\textcolor[rgb]{0,0.4,0}{#1}}
\newcommand{\blueFG}[1]{\textcolor[rgb]{0,0,0.8}{#1}}
\newcommand{\orangeFG}[1]{\textcolor[rgb]{0.8,0.4,0}{#1}}
\newcommand{\purpleFG}[1]{\textcolor[rgb]{0.4,0,0.4}{#1}}
\newcommand{\yellowFG}[1]{\textcolor{yellow}{#1}}
\newcommand{\brownFG}[1]{\textcolor[rgb]{0.5,0.2,0.2}{#1}}
\newcommand{\blackFG}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\whiteFG}[1]{\textcolor[rgb]{1,1,1}{#1}}
\newcommand{\yellowBG}[1]{\colorbox[rgb]{1,1,0.2}{#1}}
\newcommand{\brownBG}[1]{\colorbox[rgb]{1.0,0.7,0.4}{#1}}

\newcommand{\ColourStuff}{
  \newcommand{\red}{\redFG}
  \newcommand{\green}{\greenFG}
  \newcommand{\blue}{\blueFG}
  \newcommand{\orange}{\orangeFG}
  \newcommand{\purple}{\purpleFG}
  \newcommand{\yellow}{\yellowFG}
  \newcommand{\brown}{\brownFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\whiteFG}
}

\newcommand{\MonochromeStuff}{
  \newcommand{\red}{\blackFG}
  \newcommand{\green}{\blackFG}
  \newcommand{\blue}{\blackFG}
  \newcommand{\orange}{\blackFG}
  \newcommand{\purple}{\blackFG}
  \newcommand{\yellow}{\blackFG}
  \newcommand{\brown}{\blackFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\blackFG}
}

\ColourStuff

\newcommand{\D}[1]{\blue{\mathsf{#1}}}
\newcommand{\C}[1]{\red{\mathsf{#1}}}
\newcommand{\F}[1]{\green{\mathsf{#1}}}
\newcommand{\V}[1]{\purple{\mathit{#1}}}


\newcommand{\TStep}[9]{\ensuremath{\langle  #2, #3, #4 \rangle
    \mapsto_{T_{#5}} \langle  #7, #8, #9 \rangle}}
%\usetheme{Luebeck}



\title{An Opaque Model for Software Transactional Memory for Haskell}

\author{Rodrigo Ribeiro \inst{1} \and Andr\'e Du Bois \inst{2}}
\institute{DECOM, Universidade Federal de Ouro Preto (UFOP), Ouro Preto
\and
CDTec, Universidade Federal de Pelotas(UFPel), Pelotas
}

\date{\today}

\begin{document}
     \begin{frame}
         \titlepage
     \end{frame}
     \begin{frame}{Summary}
         \tableofcontents
     \end{frame}
     \section{Brief Bio}
     \begin{frame}{Brief Bio --- (I)}
        \begin{itemize}
           \item MSc in Computer Science (UFMG) - 2007;
           \item DSc in Computer Science (UFMG) - 2013;
           \item Lecturer at Universidade Federal de Ouro Preto.
           \item Post-doc (UFPel) - 2016 - present .
        \end{itemize}
     \end{frame}
     \begin{frame}{Brief Bio --- (II)}
        \begin{itemize}
           \item Main research topic: Type theory.
           \item Applications:
           \begin{itemize}
              \item Programming languages design
              \item Formal verification --- proof assistants.
           \end{itemize}
        \end{itemize}
     \end{frame}
     \begin{frame}{Currently working in... --- (III)}
        \begin{itemize}
           \item Formal semantics for STM.
           \item Formal verification of Featherweight Java typechecker.
           \item Formal semantics and verification of DSLs for temporal media (music, video, etc).
           \item Other projects
           \begin{itemize}
              \item Formal verification of parsing algorithms.
              \item Compilation of partial C programs.
           \end{itemize}
        \end{itemize}
     \end{frame}
     \begin{frame}{This Talk --- (IV)}
        \begin{itemize}
           \item Formal semantics for STM.
           \begin{itemize}
              \item Needed to ensure safety properties of STM.
              \item Results reported in a paper submitted to Haskell Symposium 2017.
              \item We assume that audience is familiar with Haskell syntax and
                    monadic programming. 
           \end{itemize}
        \end{itemize}
     \end{frame}
     \section{Introduction}
     \subsection{Motivation}
     \begin{frame}{Multicores are coming! --- (V)}
        \begin{itemize}
           \item For 50 years, hardware designers delivered 40-50\% increases per year in sequential program performance.
           \item Around 2004, this promise fails because power and cooling issues made impossible to increase clock
                 frequencies.
           \item Result: If we want better performance, parallelism is no longer an option!
        \end{itemize}
     \end{frame}
     \begin{frame}{Parallelism and multicores --- (VI)}
         \begin{itemize}
            \item Parallelism is essential to improve performance on a multi-core machine.
            \item Unfortunately, parallel programming is immensely more error-prone
                  than traditional sequential programming...
            \item How to do it? Locks and conditional variables.
         \end{itemize}
     \end{frame}
     \begin{frame}{Locks and programming --- (VII)}
        \begin{itemize}
           \item \textbf{Correct} use of locks can solve concurrency problems, but...
           \begin{itemize}
              \item Locks are amazingly hard to use correctly!
              \item Incorrect use of locks can cause races and deadlocks which
                    are difficult to debug.
           \end{itemize}
           \item Better solution: Transactions!
        \end{itemize}
     \end{frame}
     \begin{frame}{Transactional Memory --- (VIII)}
        \begin{itemize}
            \item Intuitivelly, write sequential code and wrap it using an \textbf{atomic} block.
            \item Atomic blocks execute in isolation.
            \begin{itemize}
               \item with automatic retry if another conflicting atomic block interferes.
            \end{itemize}
        \end{itemize}
     \end{frame}
     \begin{frame}{How does it work? --- (IX)}
        \begin{itemize}
           \item The TM runtime tries to interleave transactions.
           \item How? Here's one way:
           \begin{itemize}
              \item Read and writes happens in a transaction local log.
              \item At the end, transactions validate its log.
              \item If validation succeeds, changes are committed to memory
              \item If fails, re-runs from the beginning, discarding changes.
           \end{itemize}
        \end{itemize}
     \end{frame}
     \begin{frame}{Our focus: TL2 algorithm --- (X)}
        \begin{itemize}
           \item Uses logs and a global clock.
           \item Every transaction holds its read stamp.
           \begin{itemize}
              \item Global clock value when transaction started.
           \end{itemize}
           \item Every transactional variable has a write stamp.
           \begin{itemize}
              \item When reading, if write stamp > read stamp - abort.
           \end{itemize}
        \end{itemize}
     \end{frame}
     \subsection{Software Transactional Memory in Haskell}
     \begin{frame}{Why Haskell? --- (XI)}
        \begin{itemize}
           \item Haskell is pure functional language, i.e., by default, side-effects
                 are available only throught monads.
           \item This allows for a strict separation between effectful and
                 pure code.
           \item Using monads we can isolate transactional code from other effects
                 present in program.
        \end{itemize}
     \end{frame}
     \begin{frame}{Concurrency in Haskell --- (XII)}
        \begin{itemize}
           \item Function \ensuremath{\F{fork}} spawns a new thread.
           \item It takes an action as its argument.
        \end{itemize}
        \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}c<{\hspost}@{}}%
\column{34E}{@{}l@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\F{fork}\mathbin{::}\D{IO}\;\V{a}\to \D{IO}\;\D{ThreadId}{}\<[E]%
\\[\blanklineskip]%
\>[9]{}\F{main}\mathrel{=}\mathkw{do}\;\{\mskip1.5mu {}\<[E]%
\\
\>[9]{}\hsindent{9}{}\<[18]%
\>[18]{}\F{fork}\;\V{someAction};{}\<[E]%
\\
\>[9]{}\hsindent{9}{}\<[18]%
\>[18]{}\V{anotherAction}{}\<[34]%
\>[34]{};{}\<[34E]%
\\
\>[9]{}\hsindent{7}{}\<[16]%
\>[16]{}\mathbin{...}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
     \end{frame}
    \begin{frame}{Atomic blocks in Haskell --- (XIII)}
        \begin{itemize}
           \item Idea: use a function \ensuremath{\F{atomic}} that
                 guarantees atomic execution of its argument
                 computation atomically.
        \end{itemize}
       \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[8]{}\F{main}\mathrel{=}\mathkw{do}\;\{\mskip1.5mu {}\<[E]%
\\
\>[8]{}\hsindent{6}{}\<[14]%
\>[14]{}\V{r}\leftarrow \F{new}\;\C{0};{}\<[E]%
\\
\>[8]{}\hsindent{6}{}\<[14]%
\>[14]{}\F{fork}\;(\F{atomic}\;(\V{someAction}));{}\<[E]%
\\
\>[8]{}\hsindent{6}{}\<[14]%
\>[14]{}\F{atomic}\;(\V{anotherAction});\mathbin{...}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
     \end{frame}
     \begin{frame}{STM Haskell interface --- (XIV)}
       \begin{itemize}
          \item Transactional variables:
           \begin{itemize}
               \item \ensuremath{\mathkw{data}\;\D{TVar}\;\V{a}\mathrel{=}\mathbin{...}}
           \end{itemize}
          \item Transactional memory monad:
            \begin{itemize}
               \item \ensuremath{\mathkw{data}\;\D{STM}\;\V{a}\mathrel{=}\mathbin{...}}
            \end{itemize}
          \item Creating/ reading / writing variables.
           \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[15]{}\F{newTVar}\mathbin{::}\V{a}\to \D{STM}\;(\D{TVar}\;\V{a}){}\<[E]%
\\
\>[15]{}\F{readTVar}\mathbin{::}\D{TVar}\;\V{a}\to \D{STM}\;\V{a}{}\<[E]%
\\
\>[15]{}\F{writeTVar}\mathbin{::}\D{TVar}\;\V{a}\to \V{a}\to \D{STM}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
        \end{itemize}
     \end{frame}
     \begin{frame}{STM Haskell interface --- (XV)}
        \begin{itemize}
            \item User controlled abort of transactions.
            \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[17]{}\F{retry}\mathbin{::}\D{STM}\;\V{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
            \item Choice operator.
            \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[17]{}\F{orElse}\mathbin{::}\D{STM}\;\V{a}\to \D{STM}\;\V{a}\to \D{STM}\;\V{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
            \item Running a transaction.
            \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[17]{}\F{atomically}\mathbin{::}\D{STM}\;\V{a}\to \D{IO}\;\V{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
        \end{itemize}
     \end{frame}
     \begin{frame}{STM Haskell example --- (XVI)}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{type}\;\D{Var}\mathrel{=}\D{TVar}\;\D{Float}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{transferMoney}\mathbin{::}\D{Float}\to \D{Var}\to \D{Var}\to \D{STM}\;(){}\<[E]%
\\
\>[B]{}\F{transferMoney}\;\V{amount}\;\V{acc1}\;\V{acc2}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\mathkw{do}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\V{v}\leftarrow \F{readTVar}\;\V{acc1}{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\mathkw{if}\;\V{v}\geq \V{amount}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\mathkw{then}\;\mathkw{do}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\F{writeTVar}\;\V{acc1}\;(\V{v}\mathbin{-}\V{amount}){}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\V{v2}\leftarrow \F{readTVar}\;\V{acc2}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\F{writeTVar}\;\V{acc2}\;(\V{v2}\mathbin{+}\V{amount}){}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\mathkw{else}\;\F{retry}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
     \end{frame}
     \begin{frame}{Transactional memory summary --- (XVII)}
        \begin{itemize}
           \item TM provides a simple programming model to write concurrent code.
           \item STM simplicity (for programmer) has a price:
           \begin{itemize}
              \item Designing efficient algorithms for TM is an art.
              \item Implementations usually use subtle, but efficient, algorithms.
              \item How can we guarantee safety of an TM implementation?
              \item What means ``correctness'' for TM?
           \end{itemize}
        \end{itemize}
     \end{frame}
     \subsection{Transactional Memory Correctness}
     \begin{frame}{Correctness criteria for STM --- (XVIII)}
        \begin{itemize}
           \item Several criteria proposed in literature.
           \item They are based on the concept of TM \textbf{history}.
           \item History:
           \begin{itemize}
              \item Sequence of operations executed during a TM run.
           \end{itemize}
           \item Example:
\[H =\left\bracevert \begin{array}{c}
                 T_1.read\,x \to 0, \\
                 T_1.write(x,1), \\
                 T_2.read(x)\to 1 \\
                 T_1.commit \\
                 T_2.abort\end{array}\right\bracevert\]
        \end{itemize}
     \end{frame}
     \begin{frame}{Correctness criteria for STM --- (XIX)}
        \begin{itemize}
           \item How histories can be used to stabish correctness?
           \item A correct history should be such that:
           \begin{itemize}
              \item Commited transactions should appear to be executed with
                    no other transactions.
              \item Aborted transactions should leave no effect.
              \item Possible to find a history $H'$ s.t. there's
              a \textbf{total order} in which transactions appear to be executed.
           \end{itemize}
        \end{itemize}
     \end{frame}
     \begin{frame}{Correctness criteria for STM --- (XX)}
        \begin{itemize}
           \item How histories can be used to stabish correctness?
           \item A correct history should be such that:
           \begin{itemize}
              \item Possible to find a history $H'$ s.t. there's
              a \textbf{total order} in which transactions appear to be executed.
           \end{itemize}
           \item Here we'll focus on a criteria named \textbf{opacity}.
           \item A TM algorithm is correct if all histories generated by it are
                 opaque.
        \end{itemize}
     \end{frame}
     \section{Formal semantics for transactional memory}
     \begin{frame}{A glimpsy of our proposal --- (XXI)}
        \begin{itemize}
            \item Define a TM algorithm as a small-step operational semantics over a
                  core language.
            \item Semantics should produce the TM history.
            \item Verify that all produced histories satisfy the
                  correctness criteria.
                  \begin{itemize}
                      \item We use property based testing for this.
                  \end{itemize}
        \end{itemize}
     \end{frame}
     \subsection{Core language definition}
     \begin{frame}{Core language --- (XXII)}
         \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\orange{\texttt{-- values}}{}\<[E]%
\\
\>[B]{}\mathkw{newtype}\;\D{Val}\mathrel{=}\D{Val}\;\{\mskip1.5mu \C{ unVal }\mathbin{::}\D{Int}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\orange{\texttt{-- variables}}{}\<[E]%
\\
\>[B]{}\mathkw{newtype}\;\D{Var}\mathrel{=}\D{Var}\;\{\mskip1.5mu \C{ unVar }\mathbin{::}\D{Int}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\orange{\texttt{-- transaction identifiers}}{}\<[E]%
\\
\>[B]{}\mathkw{newtype}\;\D{Id}\mathrel{=}\D{Id}\;\{\mskip1.5mu \C{unId}\mathbin{::}\D{Int}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\orange{\texttt{-- clock values}}{}\<[E]%
\\
\>[B]{}\mathkw{newtype}\;\D{Stamp}\mathrel{=}\D{Stamp}\;\{\mskip1.5mu \C{ unStamp }\mathbin{::}\D{Int}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
     \end{frame}
     \begin{frame}{Core language --- (XXIII)}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Tran}\mathrel{=}{}\<[E]%
\\
\>[B]{}\C{TVal}\;\D{Val}{}\<[25]%
\>[25]{}\orange{\texttt{-- values}}{}\<[E]%
\\
\>[B]{}\mid \C{TRead}\;\D{Var}{}\<[25]%
\>[25]{}\orange{\texttt{-- read op.}}{}\<[E]%
\\
\>[B]{}\mid \C{TWrite}\;\D{Var}\;\D{Tran}{}\<[25]%
\>[25]{}\orange{\texttt{-- write op.}}{}\<[E]%
\\
\>[B]{}\mid \D{Tran}\C{\,\oplus_T\,}\D{Tran}{}\<[25]%
\>[25]{}\orange{\texttt{-- composition}}{}\<[E]%
\\
\>[B]{}\mid \C{TIf}\;\D{Tran}\;\D{Tran}\;\D{Tran}{}\<[25]%
\>[25]{}\orange{\texttt{-- conditional}}{}\<[E]%
\\
\>[B]{}\mid \C{TOrElse}\;\D{Tran}\;\D{Tran}{}\<[25]%
\>[25]{}\orange{\texttt{-- orElse op.}}{}\<[E]%
\\
\>[B]{}\mid \C{TRetry}{}\<[25]%
\>[25]{}\orange{\texttt{-- user abort}}{}\<[E]%
\\
\>[B]{}\mid \C{TAbort}{}\<[25]%
\>[25]{}\orange{\texttt{-- runtime abort}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
     \end{frame}
     \begin{frame}{Core language --- (XXIV)}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\orange{\texttt{-- transaction id + global clock info.}}{}\<[E]%
\\
\>[B]{}\mathkw{type}\;\D{TIdent}\mathrel{=}\D{Maybe}\;(\D{Id},\D{Stamp}){}\<[E]%
\\
\>[B]{}\mathkw{data}\;\D{Proc}\mathrel{=}{}\<[E]%
\\
\>[B]{}\C{PVal}\;\D{Val}{}\<[27]%
\>[27]{}\orange{\texttt{-- values}}{}\<[E]%
\\
\>[B]{}\mid \C{PFork}\;\D{Proc}{}\<[27]%
\>[27]{}\orange{\texttt{-- forking}}{}\<[E]%
\\
\>[B]{}\mid \C{PAtomic}\;\D{TIdent}\;\D{Tran}{}\<[27]%
\>[27]{}\orange{\texttt{-- atomic block}}{}\<[E]%
\\
\>[B]{}\mid \D{Proc}\C{\,\oplus_P\,}\D{Proc}{}\<[27]%
\>[27]{}\orange{\texttt{-- composition}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
     \end{frame}
     \subsection{Definitions and notations used}
     \begin{frame}{Transactional histories --- (XXV)}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Event}\mathrel{=}{}\<[E]%
\\
\>[B]{}\C{IRead}\;\D{Id}\;\D{Var}\;\D{Val}{}\<[21]%
\>[21]{}\orange{\texttt{-- reading a value }}{}\<[E]%
\\
\>[B]{}\mid \C{IWrite}\;\D{Id}\;\D{Var}\;\D{Val}\orange{\texttt{-- writing a value}}{}\<[E]%
\\
\>[B]{}\mid \C{IBegin}\;\D{Id}{}\<[21]%
\>[21]{}\orange{\texttt{-- beginning a transaction.}}{}\<[E]%
\\
\>[B]{}\mid \C{ICommit}\;\D{Id}{}\<[21]%
\>[21]{}\orange{\texttt{-- commit a transaction.}}{}\<[E]%
\\
\>[B]{}\mid \C{IAbort}\;\D{Id}{}\<[21]%
\>[21]{}\orange{\texttt{-- runtime abort.}}{}\<[E]%
\\
\>[B]{}\mid \C{IRetry}\;\D{Id}{}\<[21]%
\>[21]{}\orange{\texttt{-- user abort.}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathkw{type}\;\D{History}\mathrel{=}[\mskip1.5mu \D{Event}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
     \end{frame}
     \begin{frame}{Notations: Finite maps --- (XXVI)}
        \begin{itemize}
           \item Empty finite map $\bullet$.
           \item Lookup:
           \[
              h(x) = \left\{\begin{array}{ll}
                               v & \text{if } [x \mapsto v] \in h \\
                               \bot & \text{otherwise}
                            \end{array} \right.
           \]
           \item Right biased union: $h \uplus h'$.
           \item Removing: $h\mid_{x} = h - [x \mapsto v]$, for some $v$.
        \end{itemize}
     \end{frame}
     \begin{frame}{Notations: TM state --- (XXVII)}
        \begin{itemize}
           \item Heaps, read and write sets represented as finite maps.
           \item $\Theta=\langle \Theta_h, \Theta_r, \Theta_w, \Theta_T \rangle$, where:
           \begin{itemize}
              \item $\Theta_h$ : heap
              \item $\Theta_r$ and $\Theta_w$: finite maps between trans. id and its read / write sets.
              \item $\Theta_T$: finite map between trans. id and the transaction itself.
           \end{itemize}
        \end{itemize}
     \end{frame}
     \section{TL2 semantics}
     \begin{frame}{Reading a variable: intuition --- (XXVIII)}
        \begin{itemize}
           \item $\Theta(x,i,j)$: reads the value of variable $x$ in transaction $j$ which has
            read stamp $i$.
           \item How reading proceeds:
           \begin{itemize}
              \item If $x$ is in $j$ write set, return its value.
              \item If $x$ is in $j$ read set and $i$ isn't less than $x$
                      write stamp, return $x$ associated value.
              \item Lookup value in heap. If $x$ value has a stamp greather than $i$, abort.
              \item Otherwise, update read-set.
           \end{itemize}
        \end{itemize}
     \end{frame}
     \begin{frame}{Reading a variable, formally --- (XXIX)}
\begingroup
\everymath{\scriptstyle}
\large
  \[
  \Theta(x,i,j) = \left\{
  \begin{array}{ll}
     (v,\Theta) & \textit{if }\:\Theta_w(x,j) = (i',v)\\
     (v,\Theta) & \textit{if }\:\Theta_w(x,j) = \bot,\\
                & \:\:\:\:\:\Theta_r(x,j) = (i',v), i \geq i' \\
     (v, \Theta_r\,[j,x \mapsto v]) & 
        \textit{if }\:\Theta_w(x) = \Theta_r(x) = \bot,\\
                                       & \:\:\:\:\:  \Theta_h(x) = (i',v),
                                     \textit{ and } i \geq i' \\
                           \ensuremath{\C{TAbort}} & \textit{if }\: \Theta_h(x) = (i',v)
                                    \textit{ and } i < i'
  \end{array}
                                  \right.
  \]        

\endgroup
     \end{frame}
     \begin{frame}{Consistency check --- (XXX)}
        \begin{itemize}
           \item $consistent(\Theta,i,j)$ holds if transaction $j$ has finished its execution
                 on a valid view of memory.
        \end{itemize}
  \[
     \begin{array}{lcl}
\\
        consistent(\Theta,i,j) & = & \forall x. \Theta_r(x,j) = (i,v) \to \\
      & & \Theta_h(x) = (i',v) \land i \geq i'
     \end{array}
  \]
     \end{frame}
     \begin{frame}{Semantics --- (XXXI)}
        \begin{itemize}
          \item Transaction semantics uses triples $\langle \Theta, \sigma, t \rangle$:
          \begin{itemize}
             \item $\Theta$: heap and TM logs.
             \item $\sigma$: TM execution history
             \item $t$: transaction being executed.
             \item $i$: current read stamp
             \item $j$: current transation id.
          \end{itemize}
          \[\langle \Theta,\,\sigma,\,t \rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\,\sigma',\, t'\rangle\]
        \end{itemize}
     \end{frame}
     \begin{frame}{Semantics --- (XXXII)}
        \begin{itemize}
           \item Process semantics uses 5-uples
           \begin{itemize}
             \item $\Theta$: heap and TM logs.
             \item $\sigma$: TM execution history
             \item $i$: global clock
             \item $j$: last transaction id used.
             \item $p$: process being executed.
           \end{itemize}
          \[\langle \Theta,\,\sigma,\,j,\,i,\,t \rangle \mapsto_{P}
          \langle \Theta',\,\sigma',\,j',\,i',\, t'\rangle\]
        \end{itemize}
     \end{frame}
     \begin{frame}{Evaluation Contexts --- (XXXIII)}
        \[
          \begin{array}{cc}
          \begin{array}{rcl}
                      \EvalCtxTran{\cdot} & ::=    & \ensuremath{\C{TWrite}}\, v\:\EvalCtxTran{\cdot}\\
                                                   & \mid &\EvalCtxTran{\cdot}\: \ensuremath{\C{\,\oplus_T\,}} t\\
                                                   & \mid & \ensuremath{\C{TVal}}\,v \ensuremath{\C{\,\oplus_T\,}} \EvalCtxTran{\cdot}\\
                                                   & \mid & \ensuremath{\C{TIf}}\:\EvalCtxTran{\cdot}\:t\:t' \\
                                                   & \mid & \ensuremath{\C{TOrElse}}\:\EvalCtxTran{\cdot}\:t\\

          \end{array} &
          \begin{array}{rcl}
                      \EvalCtxProc{\cdot} & ::=    & \ensuremath{\C{PFork}}\:\EvalCtxProc{\cdot}\\
                                                   & \mid &\EvalCtxProc{\cdot}\:\ensuremath{\C{\,\oplus_P\,}} t\\
                                                   & \mid & \ensuremath{\C{PVal}}\,v\,\ensuremath{\C{\,\oplus_P\,}}\EvalCtxProc{\cdot}\\
                                                   & \mid & \ensuremath{\C{PAtomic}}\:\EvalCtxProc{\cdot}

          \end{array}
          \end{array}
        \]
     \end{frame}
     \begin{frame}{Evaluation context reduction --- (XXXIV)}
\[
\begin{array}{c}
  \infer[_{(TContext)}]
        { \langle \Theta,\,\sigma,\,\EvalCtxTran{t}\rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\,\sigma',\,\EvalCtxTran{t'}\rangle }
        { \langle \Theta,\,\sigma,\,t \rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\,\sigma',\, t'\rangle } \\ \\ \\
  \infer[_{(PContext)}]
        { \langle \Theta,\,\sigma,\,j,\,i,\EvalCtxProc{p} : s\rangle \mapsto_{P}
          \langle \Theta,\,\sigma',\,j',\,i',\,\EvalCtxProc{p'} : s\rangle }
        { \langle \Theta,\,\sigma,\,j,\,i,\,t \rangle \mapsto_{P}
          \langle \Theta',\,\sigma',\,j',\,i',\, t'\rangle }
\end{array}
\]        
     \end{frame}
     \begin{frame}{Read Semantics --- (XXXV)}
\[
\begin{array}{c}
  \infer[_{(TReadOk)}]
        { \langle \Theta,\, \sigma, \ensuremath{\C{TRead}}\,v \rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\, \sigma',\,\ensuremath{\C{TVal}}\,val\rangle }
        {\Theta(v,i,j) = (val,\Theta') & \sigma' = \ensuremath{\C{IRead}}\,j\,v\,val\,:\sigma}
  \\
  \\
  \\
  \infer[_{(TReadFail)}]
        { \langle \Theta,\, \sigma, \ensuremath{\C{TRead}}\,v \rangle \mapsto_{T_{i\,j}}
          \langle \Theta, \, \sigma',\, \ensuremath{\C{TAbort}} \rangle}
        {\Theta(v,i,j) = (\ensuremath{\C{TAbort}},\Theta') & \sigma' = \ensuremath{\C{IAbort}}\,j\,:\sigma} 
\end{array}
\]
     \end{frame}
     \begin{frame}{Write Semantics --- (XXXVI)}
\[
\begin{array}{c}
  \infer[_{(TWriteVal)}]
        { \langle \Theta, \, \sigma, \ensuremath{\C{TWrite}}\,v\,t\rangle \mapsto_{T_{i\,j}}
          \langle \Theta', \, \sigma',\,t\rangle}
        {\begin{array}{c}
            t = \ensuremath{\C{TVal}}\,val \\
            \sigma' = \ensuremath{\C{IWrite}}\,j\,v\,val\, : \sigma \\
            \Theta' = \langle \Theta_h, \Theta_r, \Theta_w[j,x \mapsto val], \Theta_T\rangle
         \end{array}}
  \\ \\ \\
  \infer[_{(TWriteFail)}]
        { \langle \Theta, \,\sigma, \ensuremath{\C{TWrite}}\,v\,\ensuremath{\C{TFail}}\rangle \mapsto_{T_{i\,j}}
          \langle \Theta, \, \sigma,\, \ensuremath{\C{TFail}} \rangle }
        { }
\end{array}
\]
     \end{frame}
     \begin{frame}{Composition Semantics --- (XXXVII)}
\begingroup
\everymath{\scriptstyle}
\large
\[
\begin{array}{c}
  \infer[_{(TAddVal)}]
        { \langle \Theta, \, \sigma,\, (\ensuremath{\C{TVal}}\,val_1) \ensuremath{\C{\,\oplus_T\,}} (\ensuremath{\C{TVal}}\,val_2) \rangle \mapsto_{T_{i\,j}}
          \langle \Theta, \, \sigma,\, \ensuremath{\C{TVal}}\,val \rangle}
        {val = val_1 + val_2}
  \\ \\
  \infer[_{(TAddL)}]
        { \langle \Theta,\,\sigma,\,\ensuremath{\C{TFail}}\,\ensuremath{\C{\,\oplus_T\,}} t\rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\,\sigma', \ensuremath{\C{TFail}}\rangle}
        { }

%\langle \Theta,\,\sigma,\,t\rangle \mapsto_{T_{i\,j}}
%         \langle \Theta',\,\sigma',\,|TFail|\rangle 

  \\ \\
  \infer[_{(TAddR)}]
        { \langle \Theta,\,\sigma,\, (\ensuremath{\C{TVal}}\, val) \ensuremath{\C{\,\oplus_T\,}} \ensuremath{\C{TFail}} \rangle \mapsto_{T_{i\,j}}
          \langle \Theta',\,\sigma',\,\ensuremath{\C{TFail}} \rangle }
        { }
\end{array}
\]
\endgroup
     \end{frame}
     \begin{frame}{Conditional Semantics --- (XXXVIII)}
\[
  \begin{array}{c}
     \infer[_{(TIfZero)}]
           {\langle \Theta,\sigma,\ensuremath{\C{TIf}}\,(\ensuremath{\C{TVal}\;\C{0}})\,t\,t'\rangle \mapsto_{T_{i\,j}}
            \langle \Theta,\sigma,\,t\rangle}
           {}
     \\ \\ \\
     \infer[_{(TIfNonZero)}]
           {\langle \Theta,\sigma,\ensuremath{\C{TIf}}\,(\ensuremath{\C{TVal}\;\V{v}})\,t\,t'\rangle \mapsto_{T_{i\,j}}
            \langle \Theta,\sigma,\,t'\rangle}
           {v \neq 0}    \\ \\ \\
     \infer[_{(TIfFail)}]
           { \langle \Theta,\,\sigma,\,\ensuremath{\C{TIf}}\,\ensuremath{\C{TFail}}\,t\,t'\rangle\mapsto_{T_{i\,j}}
             \langle \Theta,\,\sigma,\,\ensuremath{\C{TFail}}\rangle }
           {}

  \end{array}
\]
     \end{frame}
     \begin{frame}{OrElse Semantics --- (XXXIX)}
\begingroup
\everymath{\scriptstyle}
\large
\[
  \begin{array}{c}
     \infer[_{(TOrElseVal)}]
           { \langle \Theta,\,\sigma,\,\ensuremath{\C{TOrElse}}\,(\ensuremath{\C{TVal}}\:v)\,t'\rangle \mapsto_{T_{i\,j}}
             \langle \Theta',\,\sigma',\,\ensuremath{\C{TVal}}\,v \rangle }
           {  }
     \\ \\
     \infer[_{(TOrElseR)}]
           { \langle \Theta,\,\sigma,\,\ensuremath{\C{TOrElse}}\,\ensuremath{\C{TRetry}}\,t'\rangle \mapsto_{T_{i\,j}}
             \langle \Theta,\,\sigma,\,t' \rangle }
           { }
      \\ \\
     \infer[_{(TOrElseA)}]
           { \langle \Theta,\,\sigma,\,\ensuremath{\C{TOrElse}}\,\ensuremath{\C{TAbort}}\,t'\rangle \mapsto_{T_{i\,j}}
             \langle \Theta,\,\sigma,\,\ensuremath{\C{TAbort}} \rangle }
           {  }
  \end{array}
\]
\endgroup
     \end{frame}
     \begin{frame}{Process preemption --- (XL)}
\[
   \infer[_{(PPreempt)}]
         { \langle \Theta,\,\sigma,\,j,\,i,\,p : s\rangle \mapsto_{P}
           \langle \Theta',\,\sigma',\,j',\,i',p : s'\rangle }
         { \langle \Theta,\,\sigma,\,j,\,i,\,s\rangle \mapsto_{P}
           \langle \Theta',\,\sigma',\,j',\,i',\,s'\rangle } 
\]

     \end{frame}
     \begin{frame}{Forking semantics --- (XLI)}
\[
    \infer[_{(PFork)}]
          {\langle \Theta,\,\sigma,\,j,\,i,\, (\ensuremath{\C{PFork}}\,p) : s \rangle \mapsto_{P}
           \langle \Theta,\,\,\sigma,\,j,\,i,\, s' \rangle}
          {s' = \ensuremath{\C{PVal}}\,0 : p : s}
\]
     \end{frame}
     \begin{frame}{Atomic block semantics --- (XLII)}
\begingroup
\everymath{\scriptstyle}
\Large
\[
  \begin{array}{c}
  \infer[_{(PAt1)}]
        {\langle \Theta,\,\sigma,\,j,\,i,\,\ensuremath{\C{PAtomic}}\,\ensuremath{()}\,t : s\rangle\mapsto_{P}
         \langle \Theta',\,\sigma',\,j + 1,\,i,\, s'\rangle}
        {\begin{array}{c}
         \sigma' = \ensuremath{\C{IBegin}}\,j : \sigma\\
         s' = s \ensuremath{\plus } [\ensuremath{\C{PAtomic}}\,(i,j)\,t] \\
         \Theta_1 = \langle \Theta_h, \Theta_r\,[j\mapsto \bullet], \Theta_w\,[j\mapsto \bullet], \Theta_T\,[j\mapsto t]\rangle
         \end{array}}
  \end{array}      
\]
\endgroup
     \end{frame}
     \begin{frame}{Atomic block semantics --- (XLIII)}
\begingroup
\everymath{\scriptstyle}
\large
\[
  \begin{array}{c}
     \infer[_{(PAt2)}]
           {\langle \Theta,\,\sigma,\,j,\,i,\,\ensuremath{\C{PAtomic}}\,v : s \rangle \mapsto_{P}
            \langle \Theta',\,\sigma',\,j,\,i + 1,\,\ensuremath{\C{PVal}}\,n : s \rangle}
           {\begin{array}{cc}
              v = \ensuremath{\C{TVal}}\, n         & consistent(\Theta,i,j) \\
              \sigma' = \ensuremath{\C{ICommit}}\,j : \sigma & 
              \Theta' = \langle \Theta_h',\,\Theta_r\mid_j,\,\Theta_w\mid_j \rangle \\
              \multicolumn{2}{c}{\Theta_h'  = \Theta_h \uplus \Theta_w(j)} \\
            \end{array}}
  \end{array}
\]
\endgroup
     \end{frame}
     \begin{frame}{Atomic block semantics --- (XLIV)}
\begingroup
\everymath{\scriptstyle}
\Large
\[
  \begin{array}{c}
     \infer[_{(PAt3)}]
           {\langle \Theta,\,\sigma,\,j,\,i,\,\ensuremath{\C{PAtomic}}\,\ensuremath{\C{TFail}} : s \rangle \mapsto_{P}
            \langle \Theta',\,\sigma,\,j + 1,\,i,\,s' \rangle}
           {\begin{array}{c}
              \Theta' = \langle\Theta_h,\Theta_r\mid_j,\Theta_w\mid_j,\Theta_T\mid_j\rangle\\
              s' = s \ensuremath{\plus } \ensuremath{\C{PAtomic}}\,()\,t\,\,\,\,\,\,\,t = \Theta_t(j)
            \end{array}}
  \end{array}
\]
\endgroup
     \end{frame}
\section{Checking Opacity}
\begin{frame}{Checking Opacity --- (XLV)}
   \begin{itemize}
      \item We check safety properties using Quickcheck, a Haskell library for
            property based testing.
      \item Library formed by combinators for building generators and properties.
      \begin{itemize}
         \item Generators build random values which are checked against relevant properties.
         \item Combinators for properties mimics first-order logic conectives and quantifiers.
      \end{itemize}
   \end{itemize}
\end{frame}
\begin{frame}{Defining Opacity --- (XLVI)}
  \begin{itemize}
     \item A TM algorithm is opaque if all prefixes of its generated histories are final state opaque.
     \item In Haskell:
  \end{itemize}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{opacity}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{opacity}\mathrel{=}\F{all}\;\F{finalStateOpacity}\mathbin{\circ}\F{inits}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}
\begin{frame}{Defining Opacity --- (XLVII)}
  \begin{itemize}
     \item A history is final state opaque if exists some completion of
           it that preserves real time order and all of its transactions are legal.
     \item In Haskell:
  \end{itemize}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{finalStateOpacity}\mathbin{::}\D{History}\to \D{Bool}{}\<[E]%
\\
\>[B]{}\F{finalStateOpacity}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\F{some}\;\F{prop}\mathbin{\circ}\F{completions}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{prop}\;\V{tr}\mathrel{=}\F{preservesOrder}\;\V{tr}\mathrel{\wedge}\F{legal}\;\V{tr}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\F{some}\;\V{p}\;\V{xs}\mathrel{=}(\F{null}\;\V{xs})\mathrel{\vee}(\F{any}\;\V{p}\;\V{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{frame}
\begin{frame}{Defining Opacity --- (XLVIII)}
   \begin{itemize}
      \item Completion of a history $H$ is a history $S$, s.t.
      \begin{itemize}
         \item All live and non-commit pending transactions of $H$ are aborted in $S$; and
         \item All commit pending transactions of $H$ are aborted or committed in $S$.
      \end{itemize}
      \item Our model we do not consider commit-pending transactions.
      \item Complete a history is just abort all live transactions.
   \end{itemize}
\end{frame}
\begin{frame}{Defining Opacity --- (XLIX)}
   \begin{itemize}
      \item Real time order: $t_k \prec_H t_m$
      \begin{itemize}
         \item $t_k$ is completed and its last event occurs before $t_m$s first.
      \end{itemize}
      \item A history $H'$ preserves the real time ordering of $H$:
      \[
          \forall t_k\,t_m. t_k \prec_H t_m \to t_k \prec_{H'} t_m
      \]
   \end{itemize}
\end{frame}
\begin{frame}{Defining Opacity --- (L)}
   \begin{itemize}
      \item Legal histories.
      \begin{itemize}
         \item A history is said to be \emph{legal}
               if all values read after a write in a variable
               are equal to last value written
      \end{itemize}
   \end{itemize}
\end{frame}
\begin{frame}{Checking Opacity --- (LI)}
   \begin{itemize}
      \item We use function \ensuremath{\F{opacity}} as a Quickcheck property over
            histories produced by executing random generated programs.
      \item Semantics passes in all test-suit runs.
   \end{itemize}
\end{frame}
\begin{frame}{Checking Opacity --- (LII)}
   \begin{itemize}
      \item So, our semantics does enjoy opacity?
      \begin{itemize}
         \item As pointed by Djikstra: ``Tests can only prove the presence of bugs...''.
      \end{itemize}
      \item In order to afirm this categorically, we need a formal proof.
      \begin{itemize}      
         \item A venue that we intend to pursue in future work.
      \end{itemize}
   \end{itemize}
\end{frame}
\section{Conclusions}
\begin{frame}{History not told... (LIII)}
   \begin{itemize}
      \item Alternative STM-Haskell based semantics (does not have opacity).
      \item Compilation to virtual machine.
      \item Another correctness criteria: markability.
      \item Other properties verified
      \begin{itemize}
         \item Compilation preserves safety properties.
         \item Equivalence of safety properties.
      \end{itemize}
   \end{itemize}
\end{frame}
\begin{frame}{Conclusions --- (LIV)}
   \begin{itemize}
      \item We define small-step operational semantics for STM-Haskell like language.
      \begin{itemize}
         \item TL2-based semantics.
         \item STM-Haskell based semantics.
      \end{itemize}
      \item Implemented interpreters for the semantics and relevant properties over it using Haskell.
   \end{itemize}
\end{frame}
\begin{frame}{Conclusions --- (LV)}
   \begin{itemize}
      \item Property based testing.
      \begin{itemize}
         \item Allows for quickly identify errors in semantics --- counter-examples.
         \item Provides some degree of assurance, before using more formal approachs.
      \end{itemize}
   \end{itemize}
\end{frame}
\end{document}
